

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyWFL.rand &mdash; PyWFL 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyWFL 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="PyWFL" href="../PyWFL.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PyWFL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">PyWFL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">PyWFL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../PyWFL.html">PyWFL</a> &raquo;</li>
      
    <li>PyWFL.rand</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for PyWFL.rand</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">_rand</span>


<div class="viewcode-block" id="color_noise"><a class="viewcode-back" href="../../PyWFL.rand.html#PyWFL.rand.color_noise">[docs]</a><span class="k">def</span> <span class="nf">color_noise</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">iseed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get time series of (color) noise with pre-determined power spectra :math:`P(f)` which is proportional to :math:`1/f^{\\beta}`.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : number of data to be generated</span>
<span class="sd">        beta (float): spectral densities parameter that vary as powers of inverse frequency. More precisely, the power spectra :math:`P(f)` is proportional to :math:`1/f^{\\beta}`. Note, :math:`0&lt;=\\beta&lt;=3`.</span>
<span class="sd">        iseed (int) : default 0, use system clock as the random seed, different time with different random array, if not equal to 0, then the same iseed get the same random array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : (color) noise time series (generated from random number) with special spectra :math:`P(f) \propto 1 / f^{\\beta}`</span>

<span class="sd">    Notes:</span>
<span class="sd">        The **same random seed** will produce the same noise time series.</span>
<span class="sd">        Noise (or color noise) will be generated that has spectral densities that vary as powers of inverse frequency, more precisely, the power spectra :math:`P(f)` is proportional to :math:`1/f^{\\beta}` for :math:`\\beta &gt;= 0`.  When :math:`\\beta` is 0 the noise is referred to white noise, when it is 2 it is referred to as Brownian noise, and when it is 1 it normally referred to simply as :math:`1/f` noise which occurs very often in processes found in nature.</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] J. Timmer and M. Konig, On generating power law noise, Astron. Astrophys., 1995, Vol. 300, P707-710.</span>

<span class="sd">        If one plots the log(power) vs log(frequency) for noise with a particular beta value, the slope gives the value of beta. This leads to the most obvious way to generate a noise signal with a particular beta. One generates the power spectrum with the appropriate distribution and then inverse fourier transforms that into the time domain, this technique is commonly called the fBm method and is used to create many natural looking fractal forms. The basic method involves creating frequency components which have a magnitude that is generated from a Gaussian white process and scaled by the appropriate power of f. The phase is uniformly distributed on 0, 2pi. See the code for more precise details. There is a relationship between the value of beta and the fractal dimension D, namely, D = (5 - beta) / 2</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = color_noise(1024, 2, iseed=1)</span>
<span class="sd">        &gt;&gt;&gt; y = color_noise(1024, 2, iseed=1) # x and y are same, because they have same iseed.</span>
<span class="sd">        &gt;&gt;&gt; z = color_noise(1024, 1)</span>

<span class="sd">&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_rand</span><span class="o">.</span><span class="n">py_wfl_noise_color</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">iseed</span><span class="o">=</span><span class="n">iseed</span><span class="p">)</span></div>


<div class="viewcode-block" id="multi_color_noise"><a class="viewcode-back" href="../../PyWFL.rand.html#PyWFL.rand.multi_color_noise">[docs]</a><span class="k">def</span> <span class="nf">multi_color_noise</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">pieces</span><span class="p">,</span> <span class="n">iseed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get time series of multi-color noise with pre-determined power spectra :math:`P(f)` which is proportional to :math:`1/f^{\\beta}`.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : number of data to be generated</span>
<span class="sd">        beta (array): beta(m), spectral densities parameter that vary as powers of inverse frequency. More precisely, the power spectra :math:`P(f)` is proportional to :math:`1/f^{\\beta}`. Note, :math:`0&lt;=\\beta&lt;=3`.</span>
<span class="sd">        pieces (array) : The frequency index number of FFT. For example, if we want generate multi-noise color time series, the power spectrum of the time series have the below characteristics: for low frequency beta is 0.5, for middle frequency beta is 1.0, for high frequency beta is 2.0. Then beta(1:m)=beta(1:3)=0.5, 1.0, 2.0; pieces(1:m-1)=pieces(1:2)=100, 300 for n =2048. This means for FFT frequency (1~100)/n we use beta=0.5; for FFT frequency (101~300)/n we use beta =1.0,; for FFT frequency (301~1024+1)/n we use beta=2.0. Note: pieces(1:m-1) must be monotonic and pieces(m-1)&lt;=n/2+1</span>
<span class="sd">        iseed (int) : default 0, use system clock as the random seed, different time with different random array, if not equal to 0, then the same iseed get the same random array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : (color) noise time series (generated from random number) with special spectra :math:`P(f) \propto 1 / f^{\\beta}`</span>

<span class="sd">    Notes:</span>
<span class="sd">        The **same random seed** will produce the same noise time series.</span>
<span class="sd">        Noise (or color noise) will be generated that has spectral densities that vary as powers of inverse frequency, more precisely, the power spectra :math:`P(f)` is proportional to :math:`1/f^{\\beta}` for :math:`\\beta &gt;= 0`.  When :math:`\\beta` is 0 the noise is referred to white noise, when it is 2 it is referred to as Brownian noise, and when it is 1 it normally referred to simply as :math:`1/f` noise which occurs very often in processes found in nature.</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] J. Timmer and M. Konig, On generating power law noise, Astron. Astrophys., 1995, Vol. 300, P707-710.</span>

<span class="sd">        If one plots the log(power) vs log(frequency) for noise with a particular beta value, the slope gives the value of beta. This leads to the most obvious way to generate a noise signal with a particular beta. One generates the power spectrum with the appropriate distribution and then inverse fourier transforms that into the time domain, this technique is commonly called the fBm method and is used to create many natural looking fractal forms. The basic method involves creating frequency components which have a magnitude that is generated from a Gaussian white process and scaled by the appropriate power of f. The phase is uniformly distributed on 0, 2pi. See the code for more precise details. There is a relationship between the value of beta and the fractal dimension D, namely, D = (5 - beta) / 2</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; x = multi_color_noise(2048, [0.5, 1.0, 2.0], [100, 300])</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(x)</span>
<span class="sd">        &gt;&gt;&gt; plt.show()</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`color_noise`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_rand</span><span class="o">.</span><span class="n">py_wfl_noise_multi_color</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">pieces</span><span class="p">,</span> <span class="n">iseed</span><span class="o">=</span><span class="n">iseed</span><span class="p">)</span></div>


<div class="viewcode-block" id="random_mt"><a class="viewcode-back" href="../../PyWFL.rand.html#PyWFL.rand.random_mt">[docs]</a><span class="k">def</span> <span class="nf">random_mt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ran_type</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">iseed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produces uniform distribution random numbers by MT (Mersenne Twister) method.</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Number of normal distribution</span>
<span class="sd">        interval (list) : interval[2], The interval domain for uniform distribution uni</span>
<span class="sd">        ran_type (int) : ran_type is one of 1, 2, 3, 4. Default is ran_type==3. This parameter choice use which uniform random to produce normal random data. The uniform random period is: It is proved that the period is 219937-1, and 623-dimensional equidistribution property is assured. [0,1],[0,1) and (0,1) for ran_type= 1,2 and 3 in 32 bit precision, and (0,1) for ran_type=4 in 53 bit precision.</span>
<span class="sd">        iseed (int) : default 0, use system clock as the random seed, different time with different random array, if not equal to 0, then the same iseed get the same random array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : Random array</span>

<span class="sd">    Notes:</span>
<span class="sd">        Give input n then produces standard normal distribution random numbers x(n). If iseed is 0, then get the iseed by the system clock. mean and sig is the mean and standard deviation (or root of variance) of normal distribution which means Normal (mean, sig*sig)</span>

<span class="sd">        A random generate based on a C-program for MT19937 with initialization improved 2002/1/26.</span>
<span class="sd">        C-program coded by Takuji Nishimura and Makoto Matsumoto,</span>
<span class="sd">        FORTRAN77 translation by Tsuyoshi TADA. (2005/12/19)</span>
<span class="sd">        Fortran90 coded base on the above Fortran77 version, and re-interfaced to easy use by Dr. Yan Haoming(2015.4.29)</span>

<span class="sd">    References:</span>
<span class="sd">        ..[1] http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`random_mt_norm`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_rand</span><span class="o">.</span><span class="n">py_wfl_random_mt</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iseed</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">interval</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">interval</span><span class="p">),</span> <span class="n">ran_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="random_mt_norm"><a class="viewcode-back" href="../../PyWFL.rand.html#PyWFL.rand.random_mt_norm">[docs]</a><span class="k">def</span> <span class="nf">random_mt_norm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ran_type</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">iseed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produces standard normal distribution random numbers  by MT (Mersenne Twister) method</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Number of normal distribution</span>
<span class="sd">        mean (float) : Mean value (or mathematic expectation) of normal distribution</span>
<span class="sd">        sig (float) : Standard deviation (or root of variance) of normal distribution.</span>
<span class="sd">        ran_type (int) : ran_type is one of 1, 2, 3, 4. Default is ran_type==3. This parameter choice use which uniform random to produce normal random data. The uniform random period is: It is proved that the period is 219937-1, and 623-dimensional equidistribution property is assured. [0,1],[0,1) and (0,1) for ran_type= 1,2 and 3 in 32 bit precision, and (0,1) for ran_type=4 in 53 bit precision.</span>
<span class="sd">        iseed (int) : default 0, use system clock as the random seed, different time with different random array, if not equal to 0, then the same iseed get the same random array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : Random array</span>

<span class="sd">    Notes:</span>
<span class="sd">        Give input n then produces standard normal distribution random numbers x(n). If iseed is 0, then get the iseed by the system clock. mean and sig is the mean and standard deviation (or root of variance) of normal distribution which means Normal (mean, sig*sig)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`random_mt`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_rand</span><span class="o">.</span><span class="n">py_wfl_random_mt_norm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iseed</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">ran_type</span><span class="p">)</span></div>


<div class="viewcode-block" id="random_norm"><a class="viewcode-back" href="../../PyWFL.rand.html#PyWFL.rand.random_norm">[docs]</a><span class="k">def</span> <span class="nf">random_norm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mean</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sig</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">ran_type</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">iseed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produces standard normal distribution random numbers</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Number of normal distribution</span>
<span class="sd">        mean (float) : Mean value (or mathematic expectation) of normal distribution</span>
<span class="sd">        sig (float) : Standard deviation (or root of variance) of normal distribution.</span>
<span class="sd">        ran_type (int) : ran_type is one of -1, 0, 1, 2, 3. Default is ran_type==1. This parameter choice use which uniform random to produce normal random data. The uniform random period and speed are list as:</span>

<span class="sd">            * uniform random period: 3.1*1018 for ran_type=-1 !fastest for serial computer</span>
<span class="sd">            * 2.0*1028 for ran_type= 0 !paralle random, fastest</span>
<span class="sd">            * 8.5*1037 for ran_type= 1 !20% slower than ran_type=0 (default choose)</span>
<span class="sd">            * 8.5*1037 for ran_type= 2 !20% slower than ran_type=1</span>
<span class="sd">            * 1.8*1019 for ran_type= 3 !200% slower than ran_type 1</span>

<span class="sd">        iseed (int) : default 0, use system clock as the random seed, different time with different random array, if not equal to 0, then the same iseed get the same random array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : Random array</span>

<span class="sd">    Notes:</span>
<span class="sd">        Give input n then produces standard normal distribution random numbers x(n). If iseed is 0, then get the iseed by the system clock. mean and sig is the mean and standard deviation (or root of variance) of normal distribution which means Normal (mean, sig*sig)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`random_mt`, :func:`random_mt_norm`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_rand</span><span class="o">.</span><span class="n">py_wfl_random_norm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">iseed</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="n">ran_type</span><span class="p">)</span></div>

</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, YAN Haoming, WU Dingcheng.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>