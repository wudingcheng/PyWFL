

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyWFL.spectrum &mdash; PyWFL 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyWFL 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="PyWFL" href="../PyWFL.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PyWFL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">PyWFL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">PyWFL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../PyWFL.html">PyWFL</a> &raquo;</li>
      
    <li>PyWFL.spectrum</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for PyWFL.spectrum</h1><div class="highlight"><pre>
<span></span><span class="c1"># encoding: utf-8</span>
<span class="kn">import</span> <span class="nn">_spectrum</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<div class="viewcode-block" id="arco"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.arco">[docs]</a><span class="k">def</span> <span class="nf">arco</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get auto-regressive (AR) process&#39;s parameter and autocorrelation coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array) : Array or time series to be analysis</span>
<span class="sd">        m (int) : Maximum model order given by user (or maximum lag order, e.g. AR(m) )</span>
<span class="sd">            if m &gt; 0, use m as the order of AR model; if m &lt;= 0,  then using FPE criterion to get the best order of AR model</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * co(0:m) : Array of coefficients of AR model estimated by the subroutine</span>
<span class="sd">            * cor(0:m) : Array of autocorrelation function</span>
<span class="sd">            * best_order :(Optional) Must be presented with ch at the same time. If presented, return the best order of AR model.</span>


<span class="sd">    References:</span>
<span class="sd">        .. [1] Ding Y., W. Zheng, Astronomical data processing, Nanjing Univ.  Press, Nanjing, 1990. (in Chinese)</span>
<span class="sd">        .. [2] 丁月蓉, 郑大伟 , 天文测量数据的处理方法, 南京大学出版社, 1990.</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_arco</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">x</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_arco</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="s1">&#39;fpe&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="emd"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.emd">[docs]</a><span class="k">def</span> <span class="nf">emd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">0.3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes Empirical Mode Decomposition (EMD)</span>

<span class="sd">    Args:</span>
<span class="sd">        t (array) : time index of signal :math:`X`</span>
<span class="sd">        x (array) : input signal</span>
<span class="sd">        m (int) : number of Intrinsic Mode Functions(IMFs) (last one is residual)</span>
<span class="sd">        std (float) : Standard deviation to stop the iteration (0.2&lt;=std&lt;=0.3), default is 0.3</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : IMFs (first to m-1 column is IMFs, last one (m) is residual)</span>

<span class="sd">    Notes:</span>
<span class="sd">        Edge conditions: extended symmetrical 2 points of both end maximum values and minimum values respectively.</span>
<span class="sd">        EMD_TOL is more speed than EMD, but EMD may more accuracy (personal opinion)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] N. E. Huang et al., &quot;The empirical mode decomposition and the Hilbert spectrum for non-linear and non stationary time series analysis, &quot; Proc. Royal Soc. London A, Vol. 454, pp. 903-995, 1998</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_emd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span></div>


<div class="viewcode-block" id="emd_tol"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.emd_tol">[docs]</a><span class="k">def</span> <span class="nf">emd_tol</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes Empirical Mode Decomposition (EMD)</span>

<span class="sd">    Args:</span>
<span class="sd">        t (array) : time index of signal :math:`X`</span>
<span class="sd">        x (array) : input signal</span>
<span class="sd">        m (int) : number of Intrinsic Mode Functions(IMFs) (last one is residual)</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : IMFs (first to m-1 column is IMFs, last one (m) is residual)</span>

<span class="sd">    Notes:</span>
<span class="sd">        Edge conditions: extended symmetrical 2 points of both end maximum values and minimum values respectively.</span>
<span class="sd">        Same as EMD but with different stopping criterion for sifting : at each point : mean amplitude &lt; threshold2*envelope amplitude &amp; mean of boolean array ((mean amplitude)/(envelope amplitude) &gt; threshold) &lt; tolerance &amp; the N.E. HUANG&#39;s stopping criterion sd0&gt;0.3</span>
<span class="sd">        EMD_TOL is more speed than EMD, but EMD may more accuracy (personal opinion)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] N. E. Huang et al., &quot;The empirical mode decomposition and the Hilbert spectrum for non-linear and non stationary time series analysis, &quot; Proc. Royal Soc. London A, Vol. 454, pp. 903-995, 1998</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_emd</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_spec"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fft_spec">[docs]</a><span class="k">def</span> <span class="nf">fft_spec</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get normalized Fourier spectrum, red-noise background spectrum, and 100p% (e.g. p=95%, 99%) confidence spectrum of time series.</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array) : Time series to be analyzed</span>
<span class="sd">        dt (float) : Time interval of x</span>
<span class="sd">        p (float) : Confidential level (0&lt;p&lt;1.0, typically p=0.95, p=0.99)</span>
<span class="sd">        lag1_co (float) : The lag-1 autocorrelations of x, used to output background red-noise spectrum, see FNS for details. If present, lag1_co as the lag-1 autocorrelations; if not present, use ARCO to get it, and then calculate FNS.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array:　spec(:, 4) :　Normalized Fourier spectrum. spec(:, 1), period index; spec(:, 2), Fourier spectrum of x; spec(:, 3) background Red-noise spectrum; spec(:, 4), 100p% confidence spectrum</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Torrence C., G. P. Combo, A Practical Guide to Wavelet Analysis, Bulletin of the American Meteorological Society, Vol. 79, p61-78, 1998.  E.Q. (16), (17)</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_fft_spec</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=</span><span class="n">lag1_co</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_fre"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fft_fre">[docs]</a><span class="k">def</span> <span class="nf">fft_fre</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">amp</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the period, amplitude and instantaneous phase (or real and image part) of a vector by FFT method</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array) : array (or time series) to be analyzed</span>
<span class="sd">        dt (float): time interval of array x</span>
<span class="sd">        amp (bool): if true, then get the amplitude and instantaneous phase of x; if false, then get real and image part (FFT result) of x.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * pe (array): period of time series x</span>
<span class="sd">            * am (array): Amplitude or real part (FFT result) of time series x corresponding with period pe.</span>
<span class="sd">            * ph (array): Instantaneous phase or image part (FFT result) of time series x corresponding with period pe.</span>

<span class="sd">    Notes:</span>
<span class="sd">        FFT_FRE is almost the same as FFT_PERIOD, but FFT_FRE can get instantaneous phase or it can get the real and image part of time series corresponding with the period analysis. Some times, we need this corresponding relation. E.G. , we have two time series x and y, and we want to know the spectrum of :math:`z=y/x`, then we can get  the spectrum (real and image part) of x and y first, then get :math:`z(\omega)=y(\omega)/x(\omega)`, now we get the spectrum of z.</span>
<span class="sd">        When you get the real and image part of a time series, you can get the energy spectrum of x by :math:`\sqrt(real^2+imag^2)`, but this is not the amplitude spectrum.  The energy spectrum and amplitude spectrum is not the same. (see Example for details)</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`fft_period`, :func:`wave_linear`, :func:`period_graph`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="s1">&#39;amph&#39;</span> <span class="k">if</span> <span class="n">amp</span> <span class="k">else</span> <span class="s2">&quot;reim&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_fft_fre</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="n">ch</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_preiod"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fft_preiod">[docs]</a><span class="k">def</span> <span class="nf">fft_preiod</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">modifcation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get the period and amplitude of a vector by FFT method</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array): x(n), Array (or time series) to be analyzed</span>
<span class="sd">        dt (float): Time interval of array x</span>
<span class="sd">        modification (boolean): if true, modified amplitude to more accuracy for big dt and small n*dt. For example: if dt=1.0 day, then when get annual and semiannual amplitude, no correction is needed, but when dt=1.0 month, you&#39;d better add the modification (Generally 1% increase in amplitude). More details: Markus Bath, Spectral analysis in geophysics, Elsevier Scientific Publishing Company, New York, 1974.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            pe (array): pe(n-1), period of time series x</span>
<span class="sd">            am (array): am(n-1), amplitude of time series x corresponding with period pe</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`fft_fre`, :func:`wave_linear`, :func:`period_graph`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="k">if</span> <span class="n">modifcation</span> <span class="k">else</span> <span class="s1">&#39;d&#39;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_fft_period</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="n">ch</span><span class="p">)</span></div>


<div class="viewcode-block" id="fns"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fns">[docs]</a><span class="k">def</span> <span class="nf">fns</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">lag</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Amplitude of time series x corresponding with period pe</span>

<span class="sd">    Args:</span>
<span class="sd">        n(int): The number of original time series to get lag</span>
<span class="sd">        lag (float): The lag-1 autocorrelations of the original time series, see comments for details</span>
<span class="sd">        dt (float): Time interval of the original time series</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * per (array): per(1:n/2), The periods of the original time series</span>
<span class="sd">            * pk (array): pk(1:n/2), Normalized Fourier Red / White noise spectrum</span>

<span class="sd">    Notes:</span>
<span class="sd">        If lag is not 0.0, then pk is the normalized Fourier red noise spectrum; if lag is 0.0, then pk==1.0 is the normalized Fourier white noise spectrum. To get lag from a time series, you can use subroutine ARCO (e.g call arco(n, 2, x, co, cor), then lag=(cor(1)+sqrt(cor(2)))/2. Note that, to get lag, it&#39;s better to pre-whiten (e.g remove known period signals, such as seasonal terms) the original time series first and then to get lag.</span>

<span class="sd">    References:</span>
<span class="sd">        ..[1] Torrence C., G. P. Combo, A Practical Guide to Wavelet Analysis, Bulletin of the American Meteorological Society, Vol. 79, p61-78, 1998.  E.Q. (16)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`fft_spec`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_fns</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">lag</span><span class="p">)</span></div>


<div class="viewcode-block" id="fre_wavanum"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fre_wavanum">[docs]</a><span class="k">def</span> <span class="nf">fre_wavanum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get frequency-wavenumber spectrum from time depend spherical harmonic coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">        c (array) : c(n, n, nt) Coefficients of cosine term</span>
<span class="sd">        s (array) : s(n, n, nt) Coefficients of sine term</span>
<span class="sd">        dt (float): Time interval</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * pe (nt/2):The periods in frequency domain (1/pe is the frequency)</span>
<span class="sd">            * fw (nt/2, 0:n) : Frequency-wavenumber spectrum</span>
<span class="sd">            * f (nt/2): Frequency spectrum (summed on n of fw)</span>
<span class="sd">            * w (0:n): Wavenumber spectrum (summed on nt of fw)</span>

<span class="sd">    Notes:</span>
<span class="sd">        Here, the frequency-wavenumber spectrum means the frequency-dependent degree variance power spectrum. The results of fw(nt/2, 0:n), f(nt/2) and w(0:n) is calculated from Eq. 8, 9 and 11 of Wunsch and Stammer, 1995 paper, respectively. If the unit of spatial data obtained from c, s coefficients is mm, then the unit of the above power spectrum is :math:`mm^2`.</span>

<span class="sd">    References:</span>
<span class="sd">        ..[1] Wunsch C., D. Stammer, The global frequency-wavenumber spectrum of oceanic variability estimated from TOPEX/POSEDION altimetric measurements, J. Geophys. Res., Vol. 100, No. C12, P24895-24910, 1995. (EQ. 8)</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_fre_wavenum</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="hilbert"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.hilbert">[docs]</a><span class="k">def</span> <span class="nf">hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a vector&#39;s Hilbert transform</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array) : Array (or vector) to do Hilbert transform</span>

<span class="sd">    Returns:</span>
<span class="sd">        array: Hilbert transform vector of array x</span>

<span class="sd">    Notes:</span>
<span class="sd">        Hilbert transforms are essential in understanding many modern modulation methods. These transforms effectively phase shift a function by 90 degrees independent of frequency. Of course practical implementations have limitations. For example, the phase shifting of a low frequency implies a long delay, which in turn implies a computational process that maintains a long history of the signal. Hilbert transforms are useful in creating signals with one sided Fourier transforms. Also the concepts of analytic functions and analytic signals will be shown to be related through Hilbert transforms.  (comments from the below reference of Turner)</span>

<span class="sd">        Time domain convolution:</span>

<span class="sd">            ..math::</span>
<span class="sd">                xhil(t) = x(t)/(\pi t) = \frac{1}{\pi}\int_{-\infty}^{\infty} x(u)/(t-u) du</span>

<span class="sd">        Frequency domain multiplication:</span>

<span class="sd">            ..math::</span>
<span class="sd">                xhil(\omega)=(-i\times \textrm{sgn}(\omega))) \times X(\omega)</span>

<span class="sd">            where :math:`i*i=-1`, :math:`\textrm{sgn}` is a signum function, and :math:`\textrm{sgn}(\omega)=1, 0, or -1` for :math:`\omega &gt; 0,  \omega=0, \omega &lt; 0`, respectively.</span>

<span class="sd">        Hilbert Transform Properties:</span>
<span class="sd">            see WFL</span>

<span class="sd">    Example:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_hilbert</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="hilbert_amp"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.hilbert_amp">[docs]</a><span class="k">def</span> <span class="nf">hilbert_amp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get a vector&#39;s instantaneous envelope, frequency and phase by Hilbert transform  method</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array): Array (or vector) to do Hilbert transformed</span>
<span class="sd">        dt (float): Time interval of array (or vector) x</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * amp (n): Instantaneous amplitude of array x by Hilbert transform</span>
<span class="sd">            * ph (n): Instantaneous phase of array x by Hilbert transform</span>
<span class="sd">            * fre (n): Instantaneous frequency of array x by Hilbert transform</span>

<span class="sd">    Notes:</span>

<span class="sd">        .. math::</span>
<span class="sd">            Amp &amp; = &amp; \\sqrt(x_t^2 + xhil_t^2) \\\\</span>
<span class="sd">            fre &amp; = &amp; \\arctan(xhil/x) \\\\</span>
<span class="sd">            ph  &amp; = &amp; \\frac{1}{2\\pi} \frac{fre_t}{dt}</span>

<span class="sd">        here :math:`xhil_t` is the hilbert transform of :math:`x_t`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_hilbert_amp</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="period_graph"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.period_graph">[docs]</a><span class="k">def</span> <span class="nf">period_graph</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">mw</span><span class="p">,</span> <span class="n">per_low</span><span class="p">,</span> <span class="n">per_up</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the period graph (or amplitude spectrum) of a time series</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array): Time series to be used to get period graph (or amplitude spectrum)</span>
<span class="sd">        dt (float): Time interval</span>
<span class="sd">        mw (int): The number of frequency (or period) to be analyzed</span>
<span class="sd">        per_low (float): The lowest analyzed periods</span>
<span class="sd">        per_up (float): The highest analyzed periods</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * per (array): per(mw), the analyzed periods time series</span>
<span class="sd">            * sp (array): sp(mw), The  amplitude spectrum corresponding to per</span>

<span class="sd">    References:</span>
<span class="sd">        ..[1]  Ding Yuerong, Dawei Zheng, Data processing method for astronomic observed data, Nanjing Unvi. Press, Nanjing, 1990. (in Chinese)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">        &gt;&gt;&gt; dt = 18.2621</span>
<span class="sd">        &gt;&gt;&gt; t = np.arange(400) * dt</span>
<span class="sd">        &gt;&gt;&gt; x = 0.14 * np.sin(2 * np.pi * t / 435) + 0.10 * np.sin(2 * np.pi * t / 365)</span>
<span class="sd">        &gt;&gt;&gt; per, sp = period_graph(x, dt, 50, 300, 500)</span>
<span class="sd">        &gt;&gt;&gt; plt.plot(per, sp)</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_pg</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mw</span><span class="p">,</span> <span class="n">per_low</span><span class="p">,</span> <span class="n">per_up</span><span class="p">)</span></div>


<div class="viewcode-block" id="wave_linear"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.wave_linear">[docs]</a><span class="k">def</span> <span class="nf">wave_linear</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">jtot</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">sigma</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate wavelet transform of a time series and get amplitude spectrum</span>

<span class="sd">    Args:</span>
<span class="sd">        y (array) : y(n), time series to be analyzed</span>
<span class="sd">        dt (float) : time interval of array</span>
<span class="sd">        s0 (float) : begin periods to analysis :math:`(s_0 \leq 2 dt)`</span>
<span class="sd">        step (float) : step length of period</span>
<span class="sd">        jtot (float) : total number to be analyzed, if the end periods is :math:`ss`, then :math:`jtot=(ss - s0)/ step`</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * scale (array) : scale(jtot), fourier period analyzed, it is correspond with amp(n, jtot)</span>
<span class="sd">            * amp (array) : amp(n, jtot), amplitude at desired period of input vector y</span>
<span class="sd">            * coi (array) : coi(n), cone of influence at time :math:`1 \\rightarrow n`</span>

<span class="sd">    Notes:</span>
<span class="sd">        The results of subroutine WAVE_LINEAR keep the same amplitude of sine/cosine wave at different frequencies but the white noise spectrum is ~1/scale.  See reference of Maraun and Kurths (2004) for details.</span>
<span class="sd">        Opinions from Maraun and Kurths (2004):</span>
<span class="sd">        In Fourier analysis, any normalization automatically provides the following two features:</span>
<span class="sd">            * The Gaussian white noise spectrum is (by definition) flat.</span>
<span class="sd">            * Sines of the same amplitude have the same integrated power in the frequency domain.</span>
<span class="sd">        In wavelet analysis, we meet difficulties to obtain both. For the factor c(s) in Eq. (1), Torrence and Compo (1998) and Kaiser (1994) suggest different normalizations, which only preserve one of the mentioned features. Torrence suggests c(s) = (Dt/ s)1/2 which preserves a flat white noise spectrum, but sines of equal amplitude exhibit different integrated power proportional to their oscillation scale. This choice equals Kaiser’s normalization with p = 1/2 (Eq. 3.5 in Kaiser, 1994, p. 62). Using the normalization of Kaiser with p = 0, c(s) = (Dt)1/2, sines of equal amplitude also exhibit equal integrated power (when scale is plotted logarithmically). On the other hand, the white noise spectrum is no longer flat but decreases proportional to 1/scale.  Fortunately, the normalization is only relevant for a first inspection by eye. A normalization following  c(s) = (Dt/ s)1/2 emphasizes power on high scales and could lead to misinterpretations. However, when performing a significance test, the significance level already includes the chosen normalization.</span>

<span class="sd">        Here, the Morlet wavelet is real part of general complex Morlet wavelet.</span>


<span class="sd">        1. Complex Morlet mother wavelet:</span>

<span class="sd">            .. math::</span>
<span class="sd">                \Psi(t)=\pi^{-1/4}e^{-t^2/2}e^{i \omega_0 t}</span>

<span class="sd">            where :math:`\omega_0` is the nondimensional frequency, here taken to be 6 to satisfy the admissibility condition.</span>

<span class="sd">        2. Real Morlet mother wavelet (used by WAVE_LINEAR):</span>

<span class="sd">            .. math::</span>
<span class="sd">                \Psi(t)=e^{-t^2/(2\delta^2)}\cos(\omega_0 t)</span>

<span class="sd">            where :math:`\omega_0` and :math:`\delta &gt; 0`</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Torrence, C. and Compo, G.: A practical guide to wavelet analysis, Bull. Amer. Meteor. Soc., 79, 61–78, 1998.</span>
<span class="sd">        .. [2] Liu L. T., Basic wavelet theory and its applications in geosciences, Ph. D. Dissertation, WHIGG, Wuhan, 1999 (in Chinese).</span>
<span class="sd">        .. [3] Maraun D., and J. Kurths, Cross wavelet analysis: significance testing and pitfalls, Nonlinear Processes in Geophysics, Vol. 11, P505-514, 2004.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wave_linear</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">jtot</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="conv"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.conv">[docs]</a><span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;matlab&#39;</span><span class="p">,</span> <span class="n">isconv</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_conv</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">isconv</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_window"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fft_window">[docs]</a><span class="k">def</span> <span class="nf">fft_window</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">window_type</span><span class="o">=</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="n">window_parameter</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data window used by Fourier spectrum analysis.</span>

<span class="sd">    Args:</span>
<span class="sd">        width : Length (or data number) of window</span>
<span class="sd">        window_type : Type of the data window. window_type is one of below: &#39;square&#39;, &#39;rectangular&#39;, &#39;bartlett&#39;, &#39;hamming&#39;, &#39;hanning&#39;, &#39;welch&#39;.  Note: &#39;square&#39;==&#39;rectangular&#39;.</span>
<span class="sd">        window_parameter : True for a whole window from index 1 to width, False for a half window from index 1 to width, respectively. See comments for details.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * window_result (array): output window results</span>
<span class="sd">            * bandwidth (float): bandwidth of the window. See comments for details.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The most common windows and their features are given below. This table can be used to choose the best windowing function for each application.</span>

<span class="sd">        +-------+-----------------------------+-----------------------+------------------+---------------------+</span>
<span class="sd">        |Window | Best for these Signal Types |  Frequency Resolution | Spectral Leakage |  Amplitude Accuracy |</span>
<span class="sd">        +=======+=============================+=======================+==================+=====================+</span>
<span class="sd">        |Barlett|  Random                     |Good  　　　　　　　　 |  Fair            |                Fair |</span>
<span class="sd">        +-------+-----------------------------+-----------------------+------------------+---------------------+</span>
<span class="sd">        |Hanning| Random                      |Good                   |   Good           |                Fair |</span>
<span class="sd">        +-------+-----------------------------+-----------------------+------------------+---------------------+</span>
<span class="sd">        |Hamming| Random                      |Good                   |  Fair            |                Fair |</span>
<span class="sd">        +-------+-----------------------------+-----------------------+------------------+---------------------+</span>
<span class="sd">        |Welch  | Random                      |Good                   |  Good            |                Fair |</span>
<span class="sd">        +-------+-----------------------------+-----------------------+------------------+---------------------+</span>

<span class="sd">        Whole data window equations (here m=window_length, window_parameter==&#39;one&#39;):</span>

<span class="sd">            * &#39;square&#39; or &#39;rectangular&#39; :math:`w(1:m) = 1.0`</span>
<span class="sd">            * &#39;bartlett&#39;: :math:`w(j)= 1 - \\left | \\frac{2j - 2 - m}{m} \\right |  \\quad (j=1, \\dots, m)`</span>
<span class="sd">            * &#39;hamming&#39; : :math:`w(j) = 0.54 - 0.46 \\cos(2\\pi j /m) \\quad (j=1, \\dots, m)`</span>
<span class="sd">            * &#39;hanning&#39; : :math:`w(j) = 0.5 - 0.5 \\cos(2\\pi j /m) \\quad (j=1, \\dots, m)`</span>
<span class="sd">            * &#39;welch&#39;   : :math:`w(j) = 1 - \\left ( \\frac{m^2(j-1)}{4} \\right)^2</span>

<span class="sd">        Half data window equations (here m=window_length, window_parameter==&#39;half&#39;):</span>

<span class="sd">            * &#39;square&#39; or &#39;rectangular&#39;:  :math:`w(1:m)=1.0`</span>
<span class="sd">            * &#39;bartlett&#39;: :math:`w(j)= 1 - \\left | j/m \\right |   \\quad (j=1, \\dots, m)`</span>
<span class="sd">            * &#39;hamming&#39;: :math:`w(j)=0.54+0.46 * \\cos ( \\pi*j/m)  \\quad (j=1, \\dots, m)`</span>
<span class="sd">            * &#39;hanning&#39;: :math:`w(j)=0.5+0.5 * \\cos( \\pi*j/m)     \\quad (j=1, \\dots, m)`</span>
<span class="sd">            * &#39;welch&#39;: :math:`w(j)=1- (j/m)^2                     \\quad (j=1, \\dots, m)`</span>

<span class="sd">        :math:`w(0)==1.0` for half data windows.</span>

<span class="sd">        .. math:: bandwidth = 1 / \int_{-\\infty}^{+\\infty} w(u)^2 du</span>

<span class="sd">        here, :math:`w(u)` is th window_result, and integral interval is :math:`\\left[ -m, m \\right]`. Note, here bandwidth is defined in :math:`\\left[ -m, m \\right]` but NOT in :math:`\\left[ 0, m \\right]`.</span>

<span class="sd">    Referemces:</span>
<span class="sd">        ..[1] Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications, Holden-Day, 1968. (chapter 6 and 7)</span>
<span class="sd">        ..[2] William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery, Numerical Recipes in Fortran 77, Second Edition, Syndicate of the University of Cambridge Press, p550, 1992.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; fft_window(10)</span>
<span class="sd">        &gt;&gt;&gt; fft_window(10, window=&#39;bartlett&#39;)</span>
<span class="sd">        &gt;&gt;&gt; fft_window(10, window_type=&#39;welch&#39;)</span>
<span class="sd">        &gt;&gt;&gt; fft_window(10, window_type=&#39;welch&#39;, window_parameter=False)</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">window_parameter</span> <span class="o">=</span> <span class="s1">&#39;one&#39;</span> <span class="k">if</span> <span class="n">window_parameter</span> <span class="k">else</span> <span class="s1">&#39;half&#39;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="s1">&#39;rectanglular&#39;</span><span class="p">,</span> <span class="s1">&#39;bartlett&#39;</span><span class="p">,</span> <span class="s1">&#39;hamming&#39;</span><span class="p">,</span> <span class="s1">&#39;hanning&#39;</span><span class="p">,</span> <span class="s1">&#39;welch&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">window_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;window_type should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conds</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_window</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">window_type</span><span class="p">,</span> <span class="n">window_parameter</span><span class="p">)</span></div>


<div class="viewcode-block" id="hilbert_emd_fre"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.hilbert_emd_fre">[docs]</a><span class="k">def</span> <span class="nf">hilbert_emd_fre</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fre_low</span><span class="p">,</span> <span class="n">fre_up</span><span class="p">,</span> <span class="n">emd_imf</span><span class="p">,</span> <span class="n">nfreline</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">tlow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tup</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a file which contains instantaneous amplitude and frequency of all EMD&#39;s IMFs by Hilbert method. The output file is a contour file which can be plotted in Golden Software Surfer.</span>

<span class="sd">    Args:</span>
<span class="sd">        iunit (int): File unit of output data</span>
<span class="sd">        t (array) : Time index of array (or vector) emd_imf</span>
<span class="sd">        fre_low (float) : Lower frequency to be analyzed, If fre_low&lt;=2/(n*dt) then fre_low=2/(n*dt), here dt=t(2)-t(1)</span>
<span class="sd">        fre_up (float) : Uper frequency to be analyzed, If fre_up&gt;=1/(2*dt) then fre_up=1/(2*dt), here dt=t(2)-t(1)</span>
<span class="sd">        emd_imf (array) : emd_imf[n, m], Input EMD&#39;s IMFs (n is number in time domain, m is m_th IMFs)</span>
<span class="sd">        nfreline (int) :  Line numbers of frequency between fre_low and fre_up to be analyzed</span>
<span class="sd">        filename (string) :  Output contour data filename (add &quot;.dat.grd&quot; to filename after output)</span>


<span class="sd">    Notes:</span>
<span class="sd">        :func:`hilbert_emd_fre` get an output file which can plot contour in surfer, the results is come form  :func:`hilbert_amp. We get the instantaneous envelope of EMD&#39;s IMFs by HILBERT method, then put all the data to a single Golden Software SURFER contour grid file. :func:`hilbert_emd_fre` output time, frequency, envelope for all IMFs.</span>

<span class="sd">        :func:`hilbert_emd_fre`, :func:`hilbert_emd_per`, :func:`hilbert_spec_fre` and :func:`hilbert_spec_per`  are similar. :func:`hilbert_emd_fre` and :func:`hilbert_emd_per` output more than one HILBERT amplitude in one single output file, but :func:`hilbert_spec_fre` and :func:`hilbert_spec_per` only output one instantaneous envelope in one single output file.</span>

<span class="sd">        :func:`hilbert_emd_fre` not only can be used to output instantaneous envelope of EMD&#39;s IMFs, but also can be used by any signal like EMD&#39;s IMFs. It means you can analyze two dimension signal x(n,m) where n is time number and m is m_th signal. Specially, :func:`hilbert_spec_fre` and :func:`hilbert_spec_per` is the special case of :func:`hilbert_emd_fre` and :func:`hilbert_emd_per`, in this special case, m==1.</span>

<span class="sd">        If the periods you interesting is not long, :func:`hilbert_emd_per` is more suitable than :func:`hilbert_emd_fre`, otherwise you&#39;d better choose :func:`hilbert_emd_fre`.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="n">tlow</span><span class="p">,</span> <span class="n">tup</span><span class="p">]:</span>
        <span class="n">tlow</span><span class="p">,</span> <span class="n">tup</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_hilbert_emd_fre</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fre_low</span><span class="p">,</span> <span class="n">fre_up</span><span class="p">,</span> <span class="n">emd_imf</span><span class="p">,</span> <span class="n">nfreline</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">tlow</span><span class="o">=</span><span class="n">tlow</span><span class="p">,</span> <span class="n">tup</span><span class="o">=</span><span class="n">tup</span><span class="p">)</span></div>


<div class="viewcode-block" id="hilbert_emd_per"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.hilbert_emd_per">[docs]</a><span class="k">def</span> <span class="nf">hilbert_emd_per</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">per_low</span><span class="p">,</span> <span class="n">per_up</span><span class="p">,</span> <span class="n">emd_imf</span><span class="p">,</span> <span class="n">nfreline</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">tlow</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tup</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a file which contains instantaneous amplitude and period of all EMD&#39;s IMFs by Hilbert method. The output file is a contour file which can be plotted in Golden Software Surfer.</span>

<span class="sd">    Args:</span>
<span class="sd">        iunit (int): File unit of output data</span>
<span class="sd">        t (array) : Time index of array (or vector) emd_imf</span>
<span class="sd">        fre_low (float) : Lower frequency to be analyzed, If fre_low&lt;=2/(n*dt) then fre_low=2/(n*dt), here dt=t(2)-t(1)</span>
<span class="sd">        fre_up (float) : Uper frequency to be analyzed, If fre_up&gt;=1/(2*dt) then fre_up=1/(2*dt), here dt=t(2)-t(1)</span>
<span class="sd">        emd_imf (array) : emd_imf[n, m], Input EMD&#39;s IMFs (n is number in time domain, m is m_th IMFs)</span>
<span class="sd">        nfreline (int) :  Line numbers of frequency between fre_low and fre_up to be analyzed</span>
<span class="sd">        filename (string) :  Output contour data filename (add &quot;.dat.grd&quot; to filename after output)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`hilbert_emd_fre`, :func:`hilbert`, :func:`hilbert_amp`, :func:`hilbert_emd_fre`, :func:`hilbert_spec_fre`, :func:`hilbert_spec_per`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_hilbert_emd_per</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">per_low</span><span class="p">,</span> <span class="n">per_up</span><span class="p">,</span> <span class="n">emd_imf</span><span class="p">,</span> <span class="n">nfreline</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">tlow</span><span class="o">=</span><span class="n">tlow</span><span class="p">,</span> <span class="n">tup</span><span class="o">=</span><span class="n">tup</span><span class="p">)</span></div>


<div class="viewcode-block" id="hilbert_spec_fre"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.hilbert_spec_fre">[docs]</a><span class="k">def</span> <span class="nf">hilbert_spec_fre</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fre_low</span><span class="p">,</span> <span class="n">fre_up</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nfreline</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a file which contains instantaneous amplitude and frequency of a vector by Hilbert method. The output file is a contour file which can be plotted in Golden Software Surfer.</span>

<span class="sd">    Args:</span>
<span class="sd">        iunit (int): File unit of output data</span>
<span class="sd">        t (array) : Time index of array (or vector) emd_imf</span>
<span class="sd">        fre_low (float) : Lower frequency to be analyzed, If fre_low&lt;=2/(n*dt) then fre_low=2/(n*dt), here dt=t(2)-t(1)</span>
<span class="sd">        fre_up (float) : Uper frequency to be analyzed, If fre_up&gt;=1/(2*dt) then fre_up=1/(2*dt), here dt=t(2)-t(1)</span>
<span class="sd">        x (array) :  Input vector x</span>
<span class="sd">        nfreline (int) :  Line numbers of frequency between fre_low and fre_up to be analyzed</span>
<span class="sd">        filename (string) :  Output contour data filename (add &quot;.dat.grd&quot; to filename after output)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`hilbert_emd_fre`, :func:`hilbert`, :func:`hilbert_amp`, :func:`hilbert_emd_fre`, :func:`hilbert_emd_per`, :func:`hilbert_spec_per`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_hilbert_spec_fre</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">fre_low</span><span class="p">,</span> <span class="n">fre_up</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nfreline</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="hilbert_spec_per"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.hilbert_spec_per">[docs]</a><span class="k">def</span> <span class="nf">hilbert_spec_per</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">per_low</span><span class="p">,</span> <span class="n">per_up</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nperline</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce a file which contains instantaneous amplitude and frequency of a vector by Hilbert method. The output file is a contour file which can be plotted in Golden Software Surfer.</span>

<span class="sd">    Args:</span>
<span class="sd">        iunit (int): File unit of output data</span>
<span class="sd">        t (array) : Time index of array (or vector) emd_imf</span>
<span class="sd">        fre_low (float) : Lower frequency to be analyzed, If fre_low&lt;=2/(n*dt) then fre_low=2/(n*dt), here dt=t(2)-t(1)</span>
<span class="sd">        fre_up (float) : Uper frequency to be analyzed, If fre_up&gt;=1/(2*dt) then fre_up=1/(2*dt), here dt=t(2)-t(1)</span>
<span class="sd">        x (array) :  Input vector x</span>
<span class="sd">        nfreline (int) :  Line numbers of frequency between fre_low and fre_up to be analyzed</span>
<span class="sd">        filename (string) :  Output contour data filename (add &quot;.dat.grd&quot; to filename after output)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`hilbert_emd_fre`, :func:`hilbert`, :func:`hilbert_amp`, :func:`hilbert_emd_fre`, :func:`hilbert_emd_per`, :func:`hilbert_emd_per`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_hilbert_spec_per</span><span class="p">(</span><span class="n">iunit</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">per_low</span><span class="p">,</span> <span class="n">per_up</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nperline</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span></div>


<div class="viewcode-block" id="ceof_ith_eigen"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.ceof_ith_eigen">[docs]</a><span class="k">def</span> <span class="nf">ceof_ith_eigen</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine ith eigenvalus are significant to the error level (only used after all subroutine :func:`ceof`)</span>

<span class="sd">    Args:</span>
<span class="sd">        nt (int) : Number of original time series (reference nt in :func:`ceof`)</span>
<span class="sd">        eigenvalues (array) : Eigenvalues calculate in :func:`ceof`</span>

<span class="sd">    Return:</span>
<span class="sd">        int : The ith eigenvalues are significant to the error level. Note, if ith==nmodes-1, it has two possible explanations: 1) it&#39;s true that the nmode-1 is the last eigenvalues which are significant to the error level; 2) the nmodes is small here, you should use more larger nmodes to see if ith is correct. Because here only input nmodes eigenvalues, so we can get the largest ith is nmodes-1.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] North G., T. Bell, R. Cahalan and F. J. Moeng, Sampling errors in the estimation of empirical orthogonal function, Vol.110, Mon. Wea. Rev., 699-706,1982.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_ceof_ith_eigen</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_am_window"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fft_am_window">[docs]</a><span class="k">def</span> <span class="nf">fft_am_window</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get windowed Fourier amplitude spectrum with suitable window, red-noise background amplitude spectrum, and 100p% (e.g. p=95%,99%) confidence amplitude spectrum of time series.</span>

<span class="sd">    Args:</span>
<span class="sd">        dt (float) : Time interval of x</span>
<span class="sd">        x (array) : x[n], Time series to be analyzed</span>
<span class="sd">        m (int) : Number data of window width (m&lt;=n), then the x(n) will be seprate to k=n/m or 2k-1 segments to be analysis with FFT method. See comments for details.</span>
<span class="sd">        window_type (string) : Window type used. Can be one of the belows: &#39;square&#39;, &#39;rectangular&#39;, &#39;bartlett&#39;, &#39;hamming&#39;, &#39;hanning&#39;, &#39;welch&#39;. See :func:`fft_window` for details.</span>
<span class="sd">        overlap (bool) :.If overlap, then do overlap analysis, otherwise do non-overlap analysis. See comments for details.</span>
<span class="sd">        p (float) :Confidential level (0&lt;p&lt;1.0, typically p=0.95, p=0.99)</span>
<span class="sd">        lag1_co (float) : The lag-1 autocorrelations of x, used to output background red-noise amplitude spectrum, see :func:`fns` for details. If presented, lag1_co as the lag-1 autocorrelations; if not present, use :func:`arco` to get it, and then calculate :func:`fns`. Note, if set lag1_co=0.0, the background is white-noise amplitude spectrum.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * am_window(m/2,2): Windowed Fourier amplitude spectrum of input time series. am_window(:,1), period index; am_window(:,2), windowed Fourier amplitude spectrum. Note: am_window(:,1) is different with am(:,1) output when m/=n.</span>
<span class="sd">            * am(n/2,3): Windowed Fourier amplitude spectrum of background (noise). am(:,1), period index; am(:,2) background Red-noise amplitude spectrum; am(:,3), 100p% confidence amplitude spectrum. Note that the period index of am(:,1) and am_window(:,1) is different, so you must plot am_window(:,2) with am_window(:,1) and am(:,2:3) with am(:,1) to get correct plot of windowed amplitude spectrum and corresponding noise amplitude spectrum and amplitude spectrum at confidential level p.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Here, k=n/m windows are used to filter the original x(n), which can decrease the power leakage in analysis frequency. m is the data number in each segments. If overlap==True, then the original data will be analyzed at 2k-1 segments. Each segments have half window width overlap. E.g., (0,m), (m/2+1,3m/2), (m+1,2m), ... will be analyzed. If overlap==.false., the the original data will be analyzed at k segments, no overlap in the analyzed data. E.g., (0,m), (m+1,2m), (2m+1,3m), ...</span>

<span class="sd">        comments from &quot;Numerical Recipes(NR) in Fortran77&quot;, P549, modified by WFL Author.</span>

<span class="sd">        We might want to obtain the smallest variance from a fixed amount of computation, without regard to the number of data points used. This will generally be the goal when the data are being gathered in real time, with the data-reduction being computer-limited. Alternatively, we might want to obtain the smallest variance from a fixed number of available sampled data points. This will generally be the goal in cases where the data are already recorded and we are analyzing it after the fact.</span>

<span class="sd">        In the first situation (smallest spectral variance per computer operation), it is best to segment the data without any overlapping. The first M data points constitute segment number 1; the next M data points constitute segment number 2; and so on, up to segment number K, for a total of KM sampled points. The variance in this case, relative to a single segment, is reduced by a factor K.</span>

<span class="sd">        In the second situation (smallest spectral variance per data point), it turns out to be optimal, or very nearly optimal, to overlap the segments by one half of their length. The first M points are segment number 1; the m/2+1 and 3m/2 sets of M points are segment number 2; and so on, up to segment number 2K-1. The reduction in the variance is NOT a factor of K, since the segments are not statistically independent. It can be shown that the variance is instead reduced by a factor of about 9K/11. This is, however, significantly better than the reduction of about K=2 that would have resulted if the same number of data points were segmented without overlapping.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Torrence C., G. P. Combo, A Practical Guide to Wavelet Analysis, Bulletin of the American Meteorological Society, Vol. 79, p61-78, 1998.  E.Q. (16), (17)</span>
<span class="sd">        .. [2] Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications, Holden-Day, 1968. (chapter 6 and 7)</span>
<span class="sd">        .. [3] William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery, Numerical Recipes in Fortran 77, Second Edition, Syndicate of the University of Cambridge Press, p550, 1992.</span>
<span class="sd">        .. [4] Harris, Fredric J. &quot;On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform&quot; in Proceedings of the IEEE Vol. 66, No. 1, January 1978.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_fft_am_window</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=</span><span class="n">lag1_co</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_omiga"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fft_omiga">[docs]</a><span class="k">def</span> <span class="nf">fft_omiga</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get FFT frequency value of a time series</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : number of the time series to be do FFT</span>
<span class="sd">        dt (float) : time interval of the time series to be do FFT</span>

<span class="sd">    Returns:</span>
<span class="sd">        array: omiga[n], corresponding frequency of the time series used for FFT results, unit: 1/(unit of dt)</span>

<span class="sd">    Notes:</span>
<span class="sd">        omiga(1)==0.0, omiga(i)=(i-1)/((N-1)*dt)  for i=1,N/2+1, while omiga(N/2+1) is the Nyquist positive frequency. The negative frequency is corresponding with the positive frequency but with opposite sign. If N is even, then only one positive Nyquist frequency, if N is odd, then i=N/2+2 is the negative Nyquist frequency.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_fft_omiga</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span></div>


<div class="viewcode-block" id="fft_spec_window"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.fft_spec_window">[docs]</a><span class="k">def</span> <span class="nf">fft_spec_window</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get normalized Fourier spectrum with suitable window, red-noise background spectrum, and 100p% (e.g. p=95%,99%) confidence spectrum of time series.</span>

<span class="sd">    Args:</span>
<span class="sd">        dt (float) : Time interval of x</span>
<span class="sd">        x (array) : x[n], Time series to be analyzed</span>
<span class="sd">        m (int) : Number data of window width (m&lt;=n), then the x(n) will be seprate to k=n/m or 2k-1 segments to be analysis with FFT method. See comments for details.</span>
<span class="sd">        window_type (string) : Window type used. Can be one of the belows: &#39;square&#39;, &#39;rectangular&#39;, &#39;bartlett&#39;, &#39;hamming&#39;, &#39;hanning&#39;, &#39;welch&#39;. See :func:`fft_window` for details.</span>
<span class="sd">        overlap (bool) :.If overlap, then do overlap analysis, otherwise do non-overlap analysis. See comments for details.</span>
<span class="sd">        p (float) :Confidential level (0&lt;p&lt;1.0, typically p=0.95, p=0.99)</span>
<span class="sd">        lag1_co (float) : The lag-1 autocorrelations of x, used to output background red-noise amplitude spectrum, see :func:`fns` for details. If presented, lag1_co as the lag-1 autocorrelations; if not present, use :func:`arco` to get it, and then calculate :func:`fns`. Note, if set lag1_co=0.0, the background is white-noise amplitude spectrum.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * spec_window(m/2,2):Normalized windowed Fourier spectrum. spec_window(:,1), period index; spec_window(:,2), Fourier spectrum. Note: spec_window(:,1) is different with spec(:,1) output when m/=n.</span>
<span class="sd">            * spec(n/2,3): Normalized Fourier spectrum. spec(:,1), period index; spec(:,2) background Red-noise spectrum; spec(:,3), 100p% confidence spectrum. Note that the period index of spec(:,1) and spec_window(:,1) is different, so you must plot spec_window(:,2) with spec_window(:,1) and spec(:,2:3) with spec(:,1) to get correct plot of windowed spectrum and corresponding noise spectrum and spectrum at confidential level p.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Here, k=n/m windows are used to filter the original x(n), which can decrease the power leakage in analysis frequency. m is the data number in each segments. If overlap==True, then the original data will be analyzed at 2k-1 segments. Each segments have half window width overlap. E.g., (0,m), (m/2+1,3m/2), (m+1,2m), ... will be analyzed. If overlap==.false., the the original data will be analyzed at k segments, no overlap in the analyzed data. E.g., (0,m), (m+1,2m), (2m+1,3m), ...</span>

<span class="sd">        comments from &quot;Numerical Recipes(NR) in Fortran77&quot;, P549, modified by WFL Author.</span>

<span class="sd">        We might want to obtain the smallest variance from a fixed amount of computation, without regard to the number of data points used. This will generally be the goal when the data are being gathered in real time, with the data-reduction being computer-limited. Alternatively, we might want to obtain the smallest variance from a fixed number of available sampled data points. This will generally be the goal in cases where the data are already recorded and we are analyzing it after the fact.</span>

<span class="sd">        In the first situation (smallest spectral variance per computer operation), it is best to segment the data without any overlapping. The first M data points constitute segment number 1; the next M data points constitute segment number 2; and so on, up to segment number K, for a total of KM sampled points. The variance in this case, relative to a single segment, is reduced by a factor K.</span>

<span class="sd">        In the second situation (smallest spectral variance per data point), it turns out to be optimal, or very nearly optimal, to overlap the segments by one half of their length. The first M points are segment number 1; the m/2+1 and 3m/2 sets of M points are segment number 2; and so on, up to segment number 2K-1. The reduction in the variance is NOT a factor of K, since the segments are not statistically independent. It can be shown that the variance is instead reduced by a factor of about 9K/11. This is, however, significantly better than the reduction of about K=2 that would have resulted if the same number of data points were segmented without overlapping.</span>

<span class="sd">        here the result of :func:`fft_spec_window` is NOT equivalent with the result of &quot;spctrm&quot; in NR.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Torrence C., G. P. Combo, A Practical Guide to Wavelet Analysis, Bulletin of the American Meteorological Society, Vol. 79, p61-78, 1998.  E.Q. (16), (17)</span>
<span class="sd">        .. [2] Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications, Holden-Day, 1968. (chapter 6 and 7)</span>
<span class="sd">        .. [3] William H. Press, Saul A. Teukolsky, William T. Vetterling, Brian P. Flannery, Numerical Recipes in Fortran 77, Second Edition, Syndicate of the University of Cambridge Press, p550, 1992.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_fft_spec_window</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=</span><span class="n">lag1_co</span><span class="p">)</span></div>


<div class="viewcode-block" id="mtm"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.mtm">[docs]</a><span class="k">def</span> <span class="nf">mtm</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">spec_type</span><span class="o">=</span><span class="s1">&#39;unity&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get normalized Fourier spectrum by MultiTaper Method (MTM), and red-noise background spectrum, and 100p% (e.g. p=95%,99%) confidence spectrum of time series.</span>

<span class="sd">    Args:</span>
<span class="sd">        dt (float) : Time interval or sample interval of x</span>
<span class="sd">        x (array) : Time series to be analyzed  (real, double, complex, double complex)</span>
<span class="sd">        nw (float) : :func:`dpss` orders 0 to 2*nw-1 required (2&lt;=nw&lt;n/2). Note, here, nw is real or double type. The typical values of nw is 2, 5/2, 3, 7/2, 4. Thus you can get (nw)Pi-multitapers, e.g. for nw=4, you get 4Pi-multitapers. Smaller nw higher frequency precision, greater nw smaller variance in frequency domain.</span>
<span class="sd">        spec_type (string): weight method for multitaper window. spec_type is one of below (case-insensitive):</span>
<span class="sd">            &#39;unity&#39; weighted by: 1/(2*nw-1)* sum s(f)*s(f) k=0,2*nw-1 for sum</span>
<span class="sd">            &#39;eigen&#39; weighted by: 1./sum(eigen(:)) * sum s(f)*s(f)*eigen(k) k=0,2*nw-1</span>
<span class="sd">            &#39;hires&#39; weighted by: sum s(f)*s(f)/eigen(k) k=0,2*nw-1</span>
<span class="sd">            &#39;adapt_pw&#39; weighted by: 1./ sum ( bk/bk/eigen(k)) *sum bk*bk*eigen(k)*s(f)*s(f) k=0,2*nw-1 !see Percival and Walden (1993) eq. 368a,370a</span>
<span class="sd">            &#39;adapt_th&#39; (default) weighted by: 1./dk/dk * sum dk*dk*s(f)*s(f) !see Thomson (1982, eq. 5.2, 5.3)</span>
<span class="sd">            comment on spec_type: the first 3 weighted methods are appropriate for pure white noise,  and the last two are appropriate for colored noise.</span>
<span class="sd">        p (float) : Confidential level (0&lt;p&lt;1.0, typically p=0.95, p=0.99). Note, p and red_noise_spec must be present at same time if you want to get the red_noise_spec, also you can present lag1_co or not when to calculate red_noise_spec.</span>
<span class="sd">        lag1_co (float) : The lag-1 autocorrelations of x, used to output background red-noise amplitude spectrum, see :func:`fns` for details. If presented, lag1_co as the lag-1 autocorrelations; if not present, use :func:`arco` to get it, and then calculate :func:`fns`. Note, if set lag1_co=0.0, the background is white-noise amplitude spectrum.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * f_test(n/2) (array):F-test which compares the variance of an assumed locally white noise background to the variance explained by a periodic signal. See Lees and Park(1994), eq. (6) and (7).</span>
<span class="sd">            * x_edof(n/2) (array):Effective degree of freedom in frequency domain.</span>
<span class="sd">            * red_noise_spec(n/2,3) (array):Normalized red noise Fourier spectrum. red_noise_spec(:,1), period index; red_noise_spec(:,2), AR(1) red noise Fouried spectrum; red_noise_spec(:,3)100p% confidence spectrum.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;unity&#39;</span><span class="p">,</span> <span class="s1">&#39;eigen&#39;</span><span class="p">,</span> <span class="s1">&#39;hires&#39;</span><span class="p">,</span> <span class="s1">&#39;adapt_pw&#39;</span><span class="p">,</span> <span class="s1">&#39;adapt_th&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">spec_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;spec_type should be in [</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conds</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_mtm</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">spec_type</span><span class="o">=</span><span class="n">spec_type</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=</span><span class="n">lag1_co</span><span class="p">)</span></div>


<div class="viewcode-block" id="mtm_overlap"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.mtm_overlap">[docs]</a><span class="k">def</span> <span class="nf">mtm_overlap</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">spec_type</span><span class="o">=</span><span class="s1">&#39;unity&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_mtm_overlap</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">nw</span><span class="p">,</span> <span class="n">spec_type</span><span class="o">=</span><span class="s1">&#39;unity&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span> <span class="n">lag1_co</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="multicor_spec_mtm"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.multicor_spec_mtm">[docs]</a><span class="k">def</span> <span class="nf">multicor_spec_mtm</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nw</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_multicor_spec_mtm</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">nw</span><span class="p">)</span></div>


<div class="viewcode-block" id="multicor_spectra"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.multicor_spectra">[docs]</a><span class="k">def</span> <span class="nf">multicor_spectra</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">window_type</span><span class="p">,</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.95</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get windowed FFT spectrum of auto and cross covariance/correlation of input time series.</span>

<span class="sd">    Args:</span>
<span class="sd">        dt (float) : Time interval of time series of x</span>
<span class="sd">        x(n,m) (array) :Time series to be analyzed</span>
<span class="sd">        max_lag (int) :Number data of window width (max_lag&lt;=n), w(1)=1.0, w(max_lag)=0.0.</span>
<span class="sd">        window_type (string) :Window type used. Can be one of the belows: &#39;square&#39;, &#39;rectangular&#39;, &#39;bartlett&#39;, &#39;hamming&#39;, &#39;hanning&#39;, &#39;welch&#39;. See :func:`fft_window` for details.</span>
<span class="sd">        out_type (string) : Output control. out_type=&#39;COV&#39; or &#39;COR&#39;.</span>
<span class="sd">        p(float) :Confidential level (0&lt;p&lt;1.0, typically p=0.95, p=0.99). p, cll, clu must be presented at the same time.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * pe(n/2) (array): eriods of analyzed time series x(n,m)</span>
<span class="sd">            * x_out(n/2,m,m) (array): uto and cross covariance/correlation FFT spectrum of input time series.</span>
<span class="sd">                       Auto- and cross covariances FFT spectrum for X if out_type=&#39;COV&#39;</span>
<span class="sd">                       Auto- and corss correlation FFT spectrum for X, if out_type=&#39;COR&#39;</span>
<span class="sd">                       The first index is periods( or 1/frequency). Thus x_out(:,i,j) is the covariance/correlation FFT spectrum of</span>
<span class="sd">                       the ith and jth series. And x_out(:,i,i) is the autocovariance/autocorrelation FFT spectrum of the ith series.</span>
<span class="sd">            * x_out2(n/2,m,m) (array): Phase spectrum. x_out2(:,i,i)==0.0, and x_out2(:,i,j) from -180 to 180 degree. Note, the phase may not continued with the frequency increase, so you should remove the jump by yourself.</span>
<span class="sd">            * x_out3(n/2,m,m) (array): Squared coherency spectrum. x_out3(:,i,i)=1.0, x_out3(:,i,j) from 0 to 1.0.  Please also reference :func:`corfre`.</span>
<span class="sd">            * cll(n/2,m,m) (array): Lower confidence limits for the auto-spectrum (x_out(:,i,i)) and for the squared coherency spectrum (xout3(:,i,j))</span>
<span class="sd">            * clu(n/2, m,m) (array): Upper confidence limits for the auto-spectrum (x_out(:,i,i)) and for the squared coherency spectrum (x_out3(:,i,j))</span>

<span class="sd">    Notes:</span>
<span class="sd">        If window_type=&#39;square&#39; or &#39;rectangular&#39;, max_lag=n-1, out_type=&#39;cor&#39;, then the result of WFL_MULTICOR_SPECTRA is the same with :func:`fft_spec`. See example 1 for details. If out_type=&#39;cov&#39;, then var(x) must be divide to get the same result with out_type=&#39;cor&#39;.</span>

<span class="sd">        The lower and upper confidence limits produce a confidence interval for the auto-spectrum or squared coherency spectrum. The interpretation of this e.g. 95% confidence interval is that, having constructed a random interval which has probability 0.95 of enclosing the true spectrum, we have 95% confidence on this particular occasion that the interval obtained happens to include auto-spectrum or squared coherency spectrum. Thus, the 99% confidence interval &gt; 95% confidence interval. This concept is NOT the same as significance level (or confidence level) such as used in :func:`corfre`.  　</span>

<span class="sd">        Difference between :func:`corfre` and :func:`multicor_spectra`:</span>
<span class="sd">        use different smoothing method to get squared coherency spectrum. The definition of the squared coherency spectrum is equivalent.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications, Holden-Day, 1968. (chapter 6-9)</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_multicor_spectra</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">max_lag</span><span class="p">,</span> <span class="n">window_type</span><span class="p">,</span> <span class="n">out_type</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="svd_coupled"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.svd_coupled">[docs]</a><span class="k">def</span> <span class="nf">svd_coupled</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">kmode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Do SVD decompsion for two coupled given time-space data fields.</span>

<span class="sd">    Args:</span>
<span class="sd">        S(n,mp) (array): One data set used to do SVD, must be anomalies (you can use RMAVER_NXNT or RMAVER_NTNX to get the anomalies)</span>
<span class="sd">        P(n,mq) (array): The other data set used to do SVD, must be anomalies (you can use RMAVER_NXNT or RMAVER_NTNX to get the anomalies)</span>
<span class="sd">        kmode (int) : The number of modes to be output. Note: kmode&lt;=MIN(mp,mq)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * lk (kmode)(array) : The computed singular values of covariance matrix (transport(S)* P, or in IMSL operators: S .tx. P), the largest returned first</span>
<span class="sd">            * uk(mp,kmode)(array) : The computed singular vectors of array S, the most important returned first  (or spatial pattern for S)</span>
<span class="sd">            * vk(mp,kmode)(array) : The computed singular vectors of array P, the most important returned first  (or spatial pattern for P)</span>
<span class="sd">            * ak(n,kmode)(array) : The expansion coefficients for array S  (or spatial pattern evolves in time)</span>
<span class="sd">            * bk(n,kmode)(array) : The expansion coefficients for array P  (or spatial pattern evolves in time)</span>
<span class="sd">            * scfk(kmode)(array) : The percent of Square Covariance Fraction (SCF) explained by each singular value mode</span>
<span class="sd">            * cumk(kmode)(array) : The cumulative percent of SCF explained by each singular mode. This is a bit redundant -- it&#39;s just the sum of &quot;scfk&quot;</span>
<span class="sd">            * sk(n, mp)(array) : The reconstruction of field S use first kmode. Note: must be presented with pk at the same time.</span>
<span class="sd">            * pk(n, mp)(array) : The reconstruction of field P use first kmode. Note: must be presented with sk at the same time.</span>

<span class="sd">    Notes:</span>
<span class="sd">        For the real geophysical data, to get a more reliable results, the two fields such as S and P above should be weighted by square root area weight of sqrt(cosine(latitude)) first.</span>
<span class="sd">        See also sqrootweight(nx) parameters in subroutine WFL_CEOF.</span>

<span class="sd">        If there is an error like: &quot;WFL ERROR: no convergence in wfl_svd (svdcmp)&quot;,please use double precision subroutine of WFL_SVD_COUPLED8.</span>

<span class="sd">        If there is an error with &quot;stack overflow&quot;, please see here for how to resolve it.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Mewman M. and P. D. Sardeshmukh, A caveat concerning singular value decomposition, J Climate, Vol. 8, p352-360,1995. (very important)</span>
<span class="sd">        .. [2] Bretherton C. S., C. Smith, and J. M. Wallace, An intercomparison of methods for finding coupled patterns in climate data, J Climate, Vol. 5, P541-560,1992.</span>
<span class="sd">        .. [3] Björnsson H. and S. A. Venegas, A manual for EOF and SVD analyses of climate data, C2GCR Report No, 97-1, 1997.</span>
<span class="sd">        .. [4] Hannachi A., I. T. Jolliffe and D. B. Stephenson, Empirical orthogonal function s and related techniques in atmospheric science: A review, Int. J. Climatol., Vol. 27, p1119-1152, 2007.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_svd_coupled</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">kmode</span><span class="p">)</span></div>


<div class="viewcode-block" id="wavelet"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.wavelet">[docs]</a><span class="k">def</span> <span class="nf">wavelet</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">jtot</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="mf">6.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate wavelet power spectrum of a time series using complex Molet wavelet (TC98 method)</span>

<span class="sd">    Args:</span>
<span class="sd">        dt() : Time interval of array y</span>
<span class="sd">        s0() : The smallest scale of the wavelet. Typically s0 = 2*dt. Note: for accurate reconstruction computation set s0=dt for Morlet</span>
<span class="sd">        dj() : The spacing between discrete scales. Typically dj = 0.25.  A smaller # will give better scale resolution, but be slower.</span>
<span class="sd">        jtot() : the # of scales.  Scales range from s0 up to s0*2**[(jtot-1)*dj]. Typically jtot=1+(LOG2(n*dt/s0))/dj</span>
<span class="sd">        y (n)() : Time series to be analyzed</span>
<span class="sd">        param (float) : Morlet wavelet parameters (default param=6.0). You can change the value of param if you familiar with parameters chosen, otherwise use default.</span>

<span class="sd">    Returns</span>
<span class="sd">        tuple</span>
<span class="sd">            * wave (n, jtot): (array) :complex (real and image part) of Morlet wavelet transform for input vector y versus time and scale.  CABS(wave) gives the wavelet amplitude, ATAN2(AIMAG(wave),REAL(wave)) gives wavelet phase. The wavelet power spectrum is CABS(wave)**2.</span>
<span class="sd">            * period(jtot): (array) :the &quot;Fourier&quot; periods (in time units) corresponding to &quot;scale&quot;. period corresponding with n index of wave(n,jtot).</span>
<span class="sd">            * scale (jtot): (array) :the wavelet scales that were used, it has small difference with period.</span>
<span class="sd">            * coi (n): (array) : Cone of influence at time 1-&gt;n. the e-folding factor used for the cone of influence.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The results of subroutine :func:`wavelet` do NOT keep the same amplitude of sine/cosine wave at different frequencies but keep the white noise spectrum flat.  See reference of Maraun and Kurths (2004) for details.</span>

<span class="sd">        Opinions from Maraun and Kurths (2004):</span>

<span class="sd">        In Fourier analysis, any normalization automatically provides the following two features:</span>

<span class="sd">        – The Gaussian white noise spectrum is (by definition) flat.</span>
<span class="sd">        – Sines of the same amplitude have the same integrated power in the frequency domain.</span>

<span class="sd">        In wavelet analysis, we meet difficulties to obtain both. For the factor c(s) in Eq. (1), Torrence and Compo (1998) and Kaiser (1994) suggest different normalizations, which only preserve one of the mentioned features. Torrence suggests c(s) = (Dt/ s)1/2 which preserves a flat white noise spectrum, but sines of equal amplitude exhibit different integrated power proportional to their oscillation scale. This choice equals Kaiser’s normalization with p = 1/2 (Eq. 3.5 in Kaiser, 1994, p. 62). Using the normalization of Kaiser with p = 0, c(s) = (Dt)1/2, sines of equal amplitude also exhibit equal integrated power (when scale is plotted logarithmically). On the other hand, the white noise spectrum is no longer flat but decreases proportional to 1/scale.  Fortunately, the normalization is only relevant for a first inspection by eye. A normalization following  c(s) = (Dt/ s)1/2 emphasizes power on high scales and could lead to misinterpretations. However, when performing a significance test, the significance level already includes the chosen normalization.</span>

<span class="sd">        Here, the Morlet wavelet is complex mother wavelet.</span>

<span class="sd">        Complex Morlet mother wavelet:</span>

<span class="sd">            .. math:: \\psi(t) = \\pi^{-1/4}\\exp(-t^2/2)\\exp(i \\omega_0 t)</span>

<span class="sd">         where :math:`\\omega_0` is the nondimensional frequency, here taken to be 6 to satisfy the admissibility condition.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Torrence, C. and Compo, G.: A practical guide to wavelet analysis, Bull. Amer. Meteor. Soc., 79, 61–78, 1998.</span>
<span class="sd">        .. [2] Maraun D., and J. Kurths, Cross wavelet analysis: significance testing and pitfalls, Nonlinear Processes in Geophysics, Vol. 11, P505-514, 2004.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_wavelet</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">jtot</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">)</span></div>


<div class="viewcode-block" id="wavelet_coherency"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.wavelet_coherency">[docs]</a><span class="k">def</span> <span class="nf">wavelet_coherency</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">wave1</span><span class="p">,</span> <span class="n">wave2</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate wavelet squared coherency of two time series using complex Molet wavelet</span>

<span class="sd">    Args:</span>
<span class="sd">        time(nt) (array):  time index of wavelet transform</span>
<span class="sd">        scale(nj) (array):  scale index of wavelet spectrum (accquired from WFL_WAVELET subroutine)</span>
<span class="sd">        wave1(nt,nj) (array):  complex (real and image part ) of wavelet transform for time series #1 (accquired from WFL_WAVELET subroutine)</span>
<span class="sd">        wave2(nt,nj)  (array):  complex (real and image part ) of wavelet transform for time series #2 (accquired from WFL_WAVELET subroutine)</span>
<span class="sd">        smooth (bool):  Logical. Default is True If smooth=True, then smooth the cross wavelet spectrum of wave1 and wave2 in both time and scale direction by normalized Gaussian window and box car window, respectively.</span>
<span class="sd">        m (float):   Time direction smooth parameter: the ratio between window length and scale. Default is m=8.w ():  Scale direction smooth parameter, box car smoothing window length (must be odd number, if w is even number, then w=w+1). Default is w=5. if w&lt;3, then w==3.</span>
<span class="sd">        tolerance (float):  tolerance for power1*power2, where power1=cabs(wave1)**2 and power2=cabs(wave2)**2. Default is 1.e-9. If power1*power2&lt;tolerance, then wave_coher=0.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * wave_coher (nt, nj) (array): squared wavelet coherency (0.0-1.0)</span>
<span class="sd">            * wave_phase(nt,nj) (array): the phase of corresponding squared  wavelet coherency (unit: degree, 0-360)</span>
<span class="sd">            * global_coher(nj) (array): the global (mean) squared coherency averaged over all times (0.0-1.0).</span>
<span class="sd">            * global_phase(nj) (array): the global (mean) phase averaged over all times (unit: degree, 0-360 ).</span>
<span class="sd">            * power1(nt,nj) (array): the wavelet power spectrum of time series #1, corresponding wave1. If smooth=True, then power1 is * smoothed power spectrum.</span>
<span class="sd">            * power2(nt,nj) (array): same as power1, but for time series #2.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Before call WFL_WAVELET_COHERENCY, you must first call WFL_WAVELET twice. see example for details.</span>

<span class="sd">        The cross-wavelet spectrum is defined as:</span>

<span class="sd">        Wave_Cross(nt,s)=wave1(nt,s)*conj(wave2(nt,s))</span>

<span class="sd">        Then, the squared wavelet coherency is defined as::</span>

<span class="sd">                                      | &lt; Wave_Cross(nt,ns) &gt; | 2</span>
<span class="sd">            R2(nt,s)= -------------------------------------------------</span>
<span class="sd">                             &lt; |wave1(nt,s)|2 &gt; &lt; |wave2(nt,s)|2 &gt;</span>

<span class="sd">        where, &lt; · &gt; indecates smoothing in both time and scale direction, and |  ·  | indicates the complex module.</span>

<span class="sd">        Normalized Gaussian window (to have a total weight of unity) in time direction is : exp( -t2/(2s2)</span>
<span class="sd">        Normalized box cars window are used in scale direction.</span>



<span class="sd">    References:</span>
<span class="sd">        .. [1] Torrence, C. and Webster, P.: Interdecadal Changes in the ENSO Monsoon System, Journal of Climate, 12, 2679–2690, 1999</span>
<span class="sd">        .. [2] Torrence, C. and Compo, G.: A practical guide to wavelet analysis, Bull. Amer. Meteor. Soc., 79, 61–78, 1998.</span>
<span class="sd">        .. [3] Maraun D., and J. Kurths, Cross wavelet analysis: significance testing and pitfalls, Nonlinear Processes in Geophysics, Vol. 11, P505-514, 2004.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_wavelet_coherency</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">wave1</span><span class="p">,</span> <span class="n">wave2</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="wavelet_coherency_lag"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.wavelet_coherency_lag">[docs]</a><span class="k">def</span> <span class="nf">wavelet_coherency_lag</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">wave1</span><span class="p">,</span> <span class="n">wave2</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">9</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate wavelet squared coherency of two time series using complex Molet wavelet</span>

<span class="sd">    Args:</span>
<span class="sd">        time(nt) (array):  time index of wavelet transform</span>
<span class="sd">        scale(nj) (array):  scale index of wavelet spectrum (accquired from WFL_WAVELET subroutine)</span>
<span class="sd">        wave1(nt,nj) (array):  complex (real and image part ) of wavelet transform for time series #1 (accquired from WFL_WAVELET subroutine)</span>
<span class="sd">        wave2(nt,nj)  (array):  complex (real and image part ) of wavelet transform for time series #2 (accquired from WFL_WAVELET subroutine)</span>
<span class="sd">        smooth (bool):  Logical. Default is True If smooth=True, then smooth the cross wavelet spectrum of wave1 and wave2 in both time and scale direction by normalized Gaussian window and box car window, respectively.</span>
<span class="sd">        m (float):   Time direction smooth parameter: the ratio between window length and scale. Default is m=8.w ():  Scale direction smooth parameter, box car smoothing window length (must be odd number, if w is even number, then w=w+1). Default is w=5. if w&lt;3, then w==3.</span>
<span class="sd">        tolerance (float):  tolerance for power1*power2, where power1=cabs(wave1)**2 and power2=cabs(wave2)**2. Default is 1.e-9. If power1*power2&lt;tolerance, then wave_coher=0.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * wave_coher_lag (-nt/2:nt/2, nj) (array) :lag squared wavelet coherency (0.0-1.0)</span>
<span class="sd">            * wave_phase_lag (-nt/2:nt/2,nj) (array) :the phase of corresponding lag squared  wavelet coherency (unit: degree, 0-360)</span>
<span class="sd">            * time_idx_lag (-nt/2:nt/2) (array) :lag time index</span>

<span class="sd">    Notes:</span>
<span class="sd">        Before call :func:`wavelet_coherency_lag`, you must first call WFL_WAVELET twice. see example for details.</span>

<span class="sd">        :func:`wavelet_coherency_lag` call :func:`wavelet_coherency` to calculate the global squared coherency with different lags.</span>

<span class="sd">        The default for smooth is .false. here, which is different with the default smooth=True in subroutine :func:`wavelet_coherency`</span>

<span class="sd">        The cross-wavelet spectrum is defined as:</span>

<span class="sd">        Wave_Cross(nt,s)=wave1(nt,s)*conj(wave2(nt,s))</span>

<span class="sd">        Then, the squared wavelet coherency is defined as::</span>

<span class="sd">                                      | &lt; Wave_Cross(nt,ns) &gt; | 2</span>
<span class="sd">            R2(nt,s)= -------------------------------------------------</span>
<span class="sd">                             &lt; |wave1(nt,s)|2 &gt; &lt; |wave2(nt,s)|2 &gt;</span>

<span class="sd">        where, &lt; · &gt; indecates smoothing in both time and scale direction, and |  ·  | indicates the complex module.</span>



<span class="sd">        Normalized Gaussian window (to have a total weight of unity) in time direction is : exp( -t2/(2s2)</span>

<span class="sd">        Normalized box cars window are used in scale direction.</span>

<span class="sd">        The lag squared coherency is defined as:</span>

<span class="sd">        wave_coher_lag(lag, nj)= do :func:`wavelet_coherency` (result of global_coher) using wave1(1:nt-lag,:) and wave2(lag+1:nt,:) for lag=[0,nt/2]</span>

<span class="sd">        wave_coher_lag(lag, nj)= do :func:`wavelet_coherency` (result of global_coher) using wave1(lag+1:nt,:) and wave2(1:nt-lag,:) for lag=[-nt/2,-1]</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_wavelet_coherency_lag</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">wave1</span><span class="p">,</span> <span class="n">wave2</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="n">smooth</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span></div>


<div class="viewcode-block" id="wavelet_signif"><a class="viewcode-back" href="../../PyWFL.spectrum.html#PyWFL.spectrum.wavelet_signif">[docs]</a><span class="k">def</span> <span class="nf">wavelet_signif</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="mf">6.0</span><span class="p">,</span> <span class="n">siglvl</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">lag1</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">isigtest</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_spectrum</span><span class="o">.</span><span class="n">py_wfl_wavelet_signif</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s0</span><span class="p">,</span> <span class="n">dj</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">param</span><span class="o">=</span><span class="n">param</span><span class="p">,</span> <span class="n">siglvl</span><span class="o">=</span><span class="n">siglvl</span><span class="p">,</span> <span class="n">lag1</span><span class="o">=</span><span class="n">lag1</span><span class="p">,</span> <span class="n">isigtest</span><span class="o">=</span><span class="n">isigtest</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, YAN Haoming, WU Dingcheng.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>