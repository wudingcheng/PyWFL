

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyWFL.filters &mdash; PyWFL 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyWFL 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="PyWFL" href="../PyWFL.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PyWFL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">PyWFL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">PyWFL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../PyWFL.html">PyWFL</a> &raquo;</li>
      
    <li>PyWFL.filters</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for PyWFL.filters</h1><div class="highlight"><pre>
<span></span><span class="c1"># encoding: utf-8</span>
<span class="sd">&quot;&quot;&quot;Filter functions of PyWFL&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">_filters</span>

<span class="c1"># __all__ = [&#39;fft_filter&#39;, &#39;vondrak&#39;, &#39;gauss_jekeli&#39;]</span>


<div class="viewcode-block" id="fft_filter"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.fft_filter">[docs]</a><span class="k">def</span> <span class="nf">fft_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">per1</span><span class="p">,</span> <span class="n">per2</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        x (ndarray) :Array(or time series) to be analyzed</span>
<span class="sd">        dt (float) :Time interval of array x</span>
<span class="sd">        per1 (float) :Period for filter</span>
<span class="sd">        per2 (float) :Period for filter</span>
<span class="sd">        method (string) :Filter method, should be **low**, **high**, **band**, means low pass filter, high pass filter and band pass filter.</span>
<span class="sd">            If method is **low**, all signal period greater than per1 is retained, per2 not used;</span>
<span class="sd">            If method is **high**, all signal period smaller than per1 is retained, per2 not used;</span>
<span class="sd">            If method is **band**, all signal period from per1 to per2  is retained, per1 &lt; per2;</span>

<span class="sd">        window (float) :Window width for filter, :math:`window*dt=T/5` window width (a cosine weighted window), here :math:`T` is window width, such as :math:`T=100 days`, if :math:`dt=10 days`, then you can set window as 2.0, then</span>
<span class="sd">            filter window:</span>

<span class="sd">            .. math::</span>
<span class="sd">                w_1(t) &amp; = (1+\cos(5*\pi*t/T))/2 &amp; \quad &amp;    -T &amp; &lt; t  &amp; &lt; -4T/5 \\\\</span>
<span class="sd">                w_2(t) &amp; = 1 &amp; \quad &amp;                     -4T/5 &amp; &lt; t  &amp; &lt; 4T/5  \\\\</span>
<span class="sd">                w_3(t) &amp; = (1+\cos(5*\pi*t/T))/2 &amp; \quad &amp; 4T/5  &amp; &lt; t  &amp; &lt; T</span>

<span class="sd">    Returns:</span>
<span class="sd">        array_alike: Filtered series</span>

<span class="sd">    Notes:</span>
<span class="sd">        Detials for choose suitable window</span>

<span class="sd">    Examples:</span>
<span class="sd">        ...</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`vondrak`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_fft_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">per1</span><span class="p">,</span> <span class="n">per2</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">window</span><span class="p">)</span></div>


<div class="viewcode-block" id="vondrak"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.vondrak">[docs]</a><span class="k">def</span> <span class="nf">vondrak</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        e (float) : Filter factor</span>
<span class="sd">        t (array_alike) : Time index of array x</span>
<span class="sd">        x (array_alike) : Time series to be filtered</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple : filtered time series and standard error</span>
<span class="sd">            * u (list) : Filtered time series</span>
<span class="sd">            * em (float) : Standard error between x and u.</span>


<span class="sd">    Notes:</span>
<span class="sd">        For 3 order Vondrak filter, define frequency response function as,</span>

<span class="sd">        .. math:: F(e,T)=(1+1/e (2\pi /T)^6)^{-1}=A \quad (0&lt;A&lt;1)</span>
<span class="sd">            :label: eq1</span>

<span class="sd">        and we can conclude that,</span>

<span class="sd">        .. math:: e = (2 \pi /T)^6(A/(1-A))</span>
<span class="sd">            :label: eq2</span>

<span class="sd">        .. math:: T =2 \pi ((1-A)e/A)^{-1/6}</span>
<span class="sd">            :label: eq3</span>

<span class="sd">        Then for low pass filter, set :math:`A` close to 1.0( such as :math:`A=0.99` or :math:`A=0.95`) and :math:`T` as the truncate period (which means the the signal of period of :math:`T` can be retained as :math:`(A*100)%`), and we can calculate the corresponding filter factor e by using :eq:`eq2`. By using this :math:`e` in subroutine VONDRAK, we can get the signals for all period greater than T.</span>

<span class="sd">        For high pass filter, first do the low pass filter as above, and then use the original data minus the low pass filter data, you can get the high pass filter data.</span>

<span class="sd">        For band pass filter, you can do two low pass filter :math:`e1` and :math:`e2` with the different truncate period :math:`T1` and :math:`T2`, then the difference for the two filtered data is the results of band pass filter (see Example below).</span>
<span class="sd">        To get more information of parameter e in subroutine VONDRAK, please reference:</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Yan Haoming, Zhong Min, Zhu Yaozhong, Determination of the degree of freedom of digital filtered time series with an application to the correlation analysis between the length of day and the southern oscillation index, Chinese Astronomy and Astrophysics, Vol. 28, No.1, P120-126, 2004.(in English)</span>
<span class="sd">        .. [2] 闫昊明，钟敏，朱耀仲，时间序列数字滤波后自由度的确定――应用于日长变化与南方涛动指数的相关分析，天文学报，Vol. 44, No.3, P324-329, 2003. (in Chinese)</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`fft_filter`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_vondrak</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="gauss_jekeli"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.gauss_jekeli">[docs]</a><span class="k">def</span> <span class="nf">gauss_jekeli</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="s1">&#39;distance&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        r (float): r is the distance on the Earth&#39;s surface at which weight function w has dropped to 1/2 it value at :math:`\\alpha=0` (the distance on the Earth&#39;s surface = Earth_Radius*alpha). Or we can refer to r as the averaging radius (unit: meter).</span>

<span class="sd">        distance (float): Distance from the center point for using Gaussian filtering weight function (unit: meter)</span>

<span class="sd">        ch (string): default, &#39;distance&#39;; optional in [&#39;distance&#39;, &#39;degree&#39;]</span>


<span class="sd">    Returns:</span>
<span class="sd">        float</span>
<span class="sd">            If ch==&#39;distance&#39;, the unit of distance_from_center should be in meter;</span>
<span class="sd">            If ch==&#39;degree&#39;, the unit of distance_from_center should be in degree (0°-90° );</span>

<span class="sd">    Notes:</span>
<span class="sd">        The Gaussian filtering weight function (normalized here so that the global integral of w is 1) in space domain is defined:</span>

<span class="sd">        .. math::</span>
<span class="sd">            W(\\Psi) &amp; = \\frac{2 a e^{-a(1-\\cos \\Psi)}}{1 - e^{-2a}} \\\\</span>
<span class="sd">            a &amp; = \\frac{\\ln 2}{1 - \\cos (r/R)}</span>

<span class="sd">        here :math:`\\alpha` is the angle distance on the Earth&#39;s surface, :math:`a` is the Earth&#39;s averaging radius. :math:`r` is the distance on the Earth&#39;s surface at which :math:`W(\\alpha)` has dropped to 1/2 it value at :math:`\\alpha=0` (the distance on the Earth&#39;s surface = :math:`a*\\alpha`). Or we can refer to :math:`r` as the averaging radius (unit: meter).</span>


<span class="sd">    Examples:</span>
<span class="sd">        todo</span>


<span class="sd">    References:</span>
<span class="sd">        .. [1] Jekeli, C., Alternative methods to smooth the Earth&#39;s gravity field, Rep.327, Dep. of Geod. Sci. and Surv., Ohio State Univ., Columbus,1981.</span>
<span class="sd">        .. [2] Whar, J.,M. Molenaar, F. Bryan, Time variablity of the Earth&#39;s gravity field: Hydrological and oceanic effects and their possible detection using GRACE, J. Geophys. Res. Vol.103, No.b12, P30205-30229,1998.</span>


<span class="sd">    See Also:</span>
<span class="sd">        :func:`gauss_jekeli_fre`</span>

<span class="sd">&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_gauss_jekeli</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span></div>


<div class="viewcode-block" id="gauss_jekeli_fre"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.gauss_jekeli_fre">[docs]</a><span class="k">def</span> <span class="nf">gauss_jekeli_fre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get Gaussian filtering weight function (defined by Jekeli) in frequency domain which is used to filter spherical harmonic coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">    n (int): Maximum number of Gaussian filtering weight function</span>

<span class="sd">    r (float): r is the distance on the Earth&#39;s surface at which w has dropped to 1/2 it value at alpha=0 (the distance on the Earth&#39;s surface = Earth_R*alpha). Or we can refer to r as the averaging radius (unit: meter).</span>


<span class="sd">    Returns:</span>
<span class="sd">        array_alike: w(0:n), Gaussian filtering weight function in frequency domain which is used to filter spherical harmonic coefficients</span>


<span class="sd">    Notes:</span>
<span class="sd">        Here we use the equations of C. Jekeli. So when you use the equation defined by Wahr J. (1998), note the difference for factor :math:`2*pi`. E.G., in Wahr J. (1998), eq.(30) now can omit the factor :math:`2*pi`, you can get the same results.</span>

<span class="sd">        In the frequency domain, the Gaussian filtering weight function can be computed with recursion relations (see Algorithm in GAUSS_JEKELI for definition of a):</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{W}_0 &amp; = 1 \\\\</span>
<span class="sd">            \mathbf{W}_1 &amp; = \\frac{1 + e^{-2a}}{1 - e^{-2a}} - \\frac{1}{1} \\\\</span>
<span class="sd">            \mathbf{W}_{n+1} &amp; = -\\frac{2n+1}{a} \mathbf{W}_n + \mathbf{W}_{n-1}</span>

<span class="sd">        Now :math:`w(l)` can multiply the spherical harmonic coefficients calculated from FUN_EXP_FFT, and then use FUNC_SUM_FFT to get the Gaussian filtering weighted spherical function value in space domain. This is also equivalent to do convolution between spherical function value with Gaussian filtering weighted function :math:`w(\alpha)` calculated from GAUSS_JEKELI in space domain.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Jekeli, C., Alternative methods to smooth the Earth&#39;s gravity field, Rep.327, Dep. of Geod. Sci. and Surv., Ohio State Univ., Columbus,1981.</span>
<span class="sd">        .. [2] Wahr J.,M. Molenaar, F. Bryan, Time variablity of the Earth&#39;s gravity field: Hydrological and oceanic effects and their possible detection using GRACE, J. Geophys. Res. Vol.103, No.b12, P30205-30229,1998.</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_gauss_jekeli_fre</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span></div>


<div class="viewcode-block" id="gauss_jekeli_fre_nm"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.gauss_jekeli_fre_nm">[docs]</a><span class="k">def</span> <span class="nf">gauss_jekeli_fre_nm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">r_lon</span><span class="p">,</span> <span class="n">r_lat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get non-isotropic Gaussian filtering weight function in frequency domain which is used to filter spherical harmonic coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int): Maximum number (Degree) of Gaussian filtering weight function</span>
<span class="sd">        m_order (int): Maximum order used in filter (domain: 1~N), for order grater than m_order, the filter result is 0.</span>
<span class="sd">        r_lon (float): The filter distance (in longitude) on the Earth&#39;s surface at which w has dropped to 1/2 it value at alpha=0 (the distance on the Earth&#39;s surface = Earth_R*alpha). Or we can refer r_lon as the averaging radius (unit: meter).</span>
<span class="sd">        r_lat (float): The filter distance (in latitude) on the Earth&#39;s surface at which w has dropped to 1/2 it value at alpha=0 (the distance on the Earth&#39;s surface = Earth_R*alpha). Or we can refer r_lat as the averaging radius (unit: meter).</span>

<span class="sd">    Returns:</span>
<span class="sd">        array_alike : w (0:n, 0:n), Gaussian filtering weight function in frequency domain which is used to filter spherical harmonic coefficients</span>

<span class="sd">    Notes:</span>
<span class="sd">        In the frequency domain, the non-isotropic Gaussian filtering weight function can be computed with recursion relations (see Algorithm in GAUSS_JEKELI for definition of a):</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf{W}_0 &amp; = 1 \\\\</span>
<span class="sd">            \mathbf{W}_1 &amp; = \\frac{1 + e^{-2a}}{1 - e^{-2a}} - \\frac{1}{1} \\\\</span>
<span class="sd">            \mathbf{W}_{n+1} &amp; = -\\frac{2n+1}{a} \mathbf{W}_n + \mathbf{W}_{n-1}</span>

<span class="sd">        Now :math:`w(l)` can multiply the spherical harmonic coefficients calculated from FUN_EXP_FFT, and then use FUNC_SUM_FFT to get the Gaussian filtering weighted spherical function value in space domain. This is also equivalent to do convolution between spherical function value with Gaussian filtering weighted function :math:`w(\alpha)` calculated from GAUSS_JEKELI in space domain.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Han S. C., C. k. Shum, C. Jekeli, C. Y. Kuo, C. Wilson, Non-isotropic filtering of GRACE temporal gravity for geohysical signal enhancement, Geophys. J. Int. Vol. 163, P18-25, 2005.</span>
<span class="sd">        .. [2] Jekeli, C., Alternative methods to smooth the Earth&#39;s gravity field, Rep.327, Dep. of Geod. Sci. and Surv., Ohio State Univ., Columbus,1981.</span>
<span class="sd">        .. [3] Wahr J.,M. Molenaar, F. Bryan, Time variablity of the Earth&#39;s gravity field: Hydrological and oceanic effects and their possible detection using GRACE, J. Geophys. Res. Vol.103, No.b12, P30205-30229,1998.</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`gauss_jekeli`, :func:`gauss_jekeli_fre`, :func:`func_sum_fft`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_gauss_jekeli_fre_nm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">r_lon</span><span class="p">,</span> <span class="n">r_lat</span><span class="p">)</span></div>


<div class="viewcode-block" id="weight_aver"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.weight_aver">[docs]</a><span class="k">def</span> <span class="nf">weight_aver</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">weight_no</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Do n-points weighted moving (or running) average</span>

<span class="sd">    Args:</span>
<span class="sd">    x (array) : Time series to be analyzed</span>

<span class="sd">    npoints (int) : Number of points to do moving average (npoints must be odd number and &gt;=3)</span>

<span class="sd">    weight_no (boolean) : optional, if present, then do running average (which means weight is equal); if not then do weighted running average</span>

<span class="sd">    Returns:</span>
<span class="sd">        array_alike : Output data for moving average</span>

<span class="sd">    Notes:</span>
<span class="sd">        There is a new subroutine RUNNING_MEAN which do the same thing, but can define weight function.</span>
<span class="sd">        For 3 points the equation is:</span>
<span class="sd">            .. math:: xout_i = x_{i-1}+3*x_{i} + x_{i+1} / 5.0</span>
<span class="sd">        For 5 points the equation is:</span>
<span class="sd">            .. math:: xout_i = (x_{i-2}+3*x_{i-1}+5*x_{i}+3*x_{i+1} + x_{i+2} / 13.0</span>
<span class="sd">        For npoints the weight is: `1/sum(wt), 3/sum(wt), 5/sum(wt), 7/sum(wt), 9/sum(wt), ... 3/sum(wt), 1/sum(wt)`, where :math:`wt_n=1, 3, 5, 7, 9, 11, ..., 11, 9, 7, 5, 3, 1`</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`filters`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_weight_aver</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">npoints</span><span class="p">,</span> <span class="n">weight_no</span><span class="p">)</span></div>


<div class="viewcode-block" id="butterworth"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.butterworth">[docs]</a><span class="k">def</span> <span class="nf">butterworth</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">iband</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;no_phase_shift&#39;</span><span class="p">,</span> <span class="n">edge_effect</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Using Butterworth filter (an Infinite Impulse Response (IIR) filter ) to do signal filter for low pass, high pass, band pass and band stop filter</span>

<span class="sd">    Args:</span>
<span class="sd">        L (int) : order of normalized Butterworth analog filter. L can be given by first call WFL_BUTTERWORTH_ORDER. See example for details.</span>
<span class="sd">        fl (float) : lower cut-off frequency for all filter. (unit: Hz or others, see comments)</span>
<span class="sd">        fh (float) : higher cut-off frequency for only band-pass and band-stop filter. (unit: Hz or others, see comments)</span>
<span class="sd">        iband (int): Desired digital filter type: 1--low pass   2--high pass    3--band pass    4--band stop</span>
<span class="sd">        dt (float) : Sample intervals (unit: second or others, see comments)</span>
<span class="sd">        x (array_alike) : Array of input digital signal</span>
<span class="sd">        method (string) : if method is presented and method=&#39;no_phase_shift&#39; or method=&#39;NO_PHASE_SHIFT&#39;, then WFL_BUTTERWORTH do twice Butterworth filter. Once forward and once backward. The purpose of doing forward-backward Butterworth filter is that by using this method, the phase shift of forward Butterworth filter will be erase (we can get zero phase shift output). Note, by using forward-backward Butterworth will double the order L of normalized Butterworth analog filter.</span>
<span class="sd">        edge_effect (boolean) : must be presented with &quot;method&quot; parameter at the same time. If presented and edge_effect==&#39;NO&#39;, then the large edge effects during the filter process will be mostly eliminated (though there are also some small edge effects near both ends of the filtered data ).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * xout (array_alike) : signal array after Butterworth filter</span>
<span class="sd">            * fre(n/2) (array_alike) : Frequency of Gain function (unit: Hz or others, see comments). Note, fre, amp, and ph should be presented at the same time.</span>
<span class="sd">            * amp(n/2) (array_alike) : Amplitude of Gain function</span>
<span class="sd">            * ph(n/2) (array_alike) : Phase of Gain function (unit: degree)</span>

<span class="sd">    Notes:</span>
<span class="sd">        After the Butterworth-filter, the filtered data has phase shift to compare with the original data if method is not presented. If method is presented and method\=&#39;no_phase_shift&#39; or method=&#39;NO_PHASE_SHIFT&#39;, then the filtered data will have the same (or almost the same) phase with the original data, but the order L will be doubled.</span>
<span class="sd">        There are also edge effects for the filtered data if edge_effect parameters are not presented with &quot;NO&quot; value. Be careful when use the data at the beginning and at the end of input signal if you do NOT use this parameter.</span>
<span class="sd">        Table 3.1 of Reference: Frequencies of Discrete Fourier Transform (DFT) components in different units</span>

<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |                    rad/s                    |     Hz-s    |       rad      |       Hz       |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |            Symbol :math:`\Omega`            |  :math:`Y`  | :math:`\Omega` |    :math:`f`   |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |  Frequency of :math:`X_1` :math:`2\pi/N/dt` | :math:`1/N` | :math:`2\pi/N` | :math:`1/N/dt` |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        | Frequency of :math:`X_{n/2}` :math:`\pi/dt` |     0.5     |   :math:`\pi`  | :math:`0.5/dt` |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |      Sampling Frequency :math:`2\pi/dt`     |     1.0     |  :math:`2\pi`  |  :math:`1/dt`  |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>

<span class="sd">        The unit of fl and fh is in Hz unit. if dt is in second unit, then fl or fh is in Hz unit; if dt is in day unit, then fl or fh is in 1/day unit (or cycle per day). Thus dt can be year or other unit, while fl or fh has the corresponding unit.</span>

<span class="sd">        Gain function is defined as:</span>
<span class="sd">            .. math::</span>
<span class="sd">                    Amplitude\_gain &amp; = | H(e^{j\omega}) | \\\\</span>
<span class="sd">                    Power\_gain\_in\_decibels &amp; = 10 \log10  | H(e^{j\omega}) |^2 \\\\</span>
<span class="sd">                    Phase\_shift &amp; = \\tan^{-1}{ Im ( | H^(ej\omega) | ) / Re ( | H(e^{j\omega}) | ) }</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Stearns S. D. and R. A. David, Signal processing algorithms using Fortran and c,  PTR Prentice Hall, Englewood Cliffs, New Jersey, 1993. Chapter1-7</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`butterworth_order`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">edge_effect</span> <span class="o">=</span> <span class="s1">&#39;yes&#39;</span> <span class="k">if</span> <span class="n">edge_effect</span> <span class="k">else</span> <span class="s1">&#39;no&#39;</span>
    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_wfl_butterworth</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">iband</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">edge_effect</span><span class="p">)</span></div>


<div class="viewcode-block" id="butterworth_order"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.butterworth_order">[docs]</a><span class="k">def</span> <span class="nf">butterworth_order</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine the best order of Butterworth filter (an Infinite Impulse Response (IIR) filter )</span>

<span class="sd">    Args:</span>
<span class="sd">        fl (float) : Minimum order of normalized Butterworth analog filter</span>
<span class="sd">        fh (float) : lower cut-off frequency for all filter. (unit: Hz or others, see comments)</span>
<span class="sd">        dt (float) : higher cut-off frequency for all filter. (unit: Hz or others, see comments)</span>

<span class="sd">    Returns:</span>
<span class="sd">        int : Desired digital filter type</span>
<span class="sd">            1. means low pass,</span>
<span class="sd">            2. means high pass,</span>
<span class="sd">            3. means band pass,</span>
<span class="sd">            4. means band stop.</span>


<span class="sd">    Notes:</span>
<span class="sd">        After the Butterworth-filter, the filtered data has phase shift to compare with the original data if method is not presented. If method is presented and method=&#39;no_phase_shift&#39; or method=&#39;NO_PHASE_SHIFT&#39;, then the filtered data will have the same (or almost the same) phase with the original data. , but the order L will be doubled.</span>

<span class="sd">        There are also edge effects for the filtered data if edge_effect parameters are not presented with &quot;NO&quot; value. Be careful when use the data at the beginning and at the end of input signal if you do NOT use this parameter.</span>

<span class="sd">        Table 3.1 of Reference: Frequencies of Discrete Fourier Transform (DFT) components in different units</span>

<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |                    rad/s                    |     Hz-s    |       rad      |       Hz       |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |            Symbol :math:`\Omega`            |  :math:`Y`  | :math:`\Omega` |    :math:`f`   |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |  Frequency of :math:`X_1` :math:`2\pi/N/dt` | :math:`1/N` | :math:`2\pi/N` | :math:`1/N/dt` |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        | Frequency of :math:`X_{n/2}` :math:`\pi/dt` |     0.5     |   :math:`\pi`  | :math:`0.5/dt` |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>
<span class="sd">        |      Sampling Frequency :math:`2\pi/dt`     |     1.0     |  :math:`2\pi`  |  :math:`1/dt`  |</span>
<span class="sd">        +---------------------------------------------+-------------+----------------+----------------+</span>

<span class="sd">        The unit of fl and fh is in Hz unit. if dt is in second unit, then fl or fh is in Hz unit; if dt is in day unit, then fl or fh is in 1/day unit (or cycle per day). Thus dt can be year or other unit, while fl or fh has the corresponding unit.</span>

<span class="sd">        Gain function is defined as:</span>
<span class="sd">            .. math::</span>
<span class="sd">                    Amplitude\_gain &amp; = | H(e^{j\omega}) | \\\\</span>
<span class="sd">                    Power\_gain\_in\_decibels &amp; = 10 \log10  | H(e^{j\omega}) |^2 \\\\</span>
<span class="sd">                    Phase\_shift &amp; = \tan^{-1}{ Im [ | H^(ej\omega) | ] / Re [ | H(e^{j\omega}) | ] }</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Stearns S. D. and R. A. David, Signal processing algorithms using Fortran and c, PTR Prentice Hall, Englewood Cliffs, New Jersey, 1993. Chapter1-7</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`butterworth`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_wfl_butterworth_order</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">iband</span><span class="p">)</span></div>


<div class="viewcode-block" id="running_mean"><a class="viewcode-back" href="../../PyWFL.filters.html#PyWFL.filters.running_mean">[docs]</a><span class="k">def</span> <span class="nf">running_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;**running\_mean** ( real / double / complex / double complex )</span>
<span class="sd">    Do *n*-points weighted moving (or running) average using convolution</span>
<span class="sd">    method</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array_alike) : Time series to be analyzed</span>
<span class="sd">        m (int) :Number of points to do moving average (**m** must be odd number and &gt;=3)</span>
<span class="sd">        weight (array_alike) : (Optional; Input) If NOT present *weight*, then do running average (which means weight is equal); if present, then do weighted running average. For real/double precision call, the final weight is weight/sum(weight); for complex/double complex call, the final weight is weight/sum(abs(weight)). Thus the weight is normalized in the inner of subroutine WFL\_RUNNING\_MEAN to have a total weight of unity.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array</span>
<span class="sd">            Output data for moving average</span>


<span class="sd">    Notes:</span>
<span class="sd">        weight=1.0 means running average; weight=[1, 3, 5, 7, 9..or anything like 8,4, 5,2, ...] means weighted running average, the true weight used in the **WFL\_RUNNING\_MEAN** is weight/sum(weight) for real/double calling, and weight/sum(abs(weight)) for complex/double complex calling.  **WFL\_RUNNING\_MEAN** is the same as `WEIGHT\_AVER &lt;weight_aver.htm&gt;`__ but using different method. Note, here the weight can be set as your own, while in `WEIGHT\_AVER &lt;weight_aver.htm&gt;`__, you only have two type weight.</span>

<span class="sd">        xout=conv(x, weight/sum(weight)) #for real/double</span>
<span class="sd">        xout=conv(x, weight/sum(abs(weight)) ) #for complex/double complex</span>

<span class="sd">    Examples:</span>
<span class="sd">        　todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`filters`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span> <span class="o">!=</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weigt length no equal to window m&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_wfl_running_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ones</span>
        <span class="k">return</span> <span class="n">_filters</span><span class="o">.</span><span class="n">py_wfl_running_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ones</span><span class="p">(</span><span class="n">m</span><span class="p">))</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, YAN Haoming, WU Dingcheng.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>