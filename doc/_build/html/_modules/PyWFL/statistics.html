

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyWFL.statistics &mdash; PyWFL 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyWFL 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="PyWFL" href="../PyWFL.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PyWFL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">PyWFL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">PyWFL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../PyWFL.html">PyWFL</a> &raquo;</li>
      
    <li>PyWFL.statistics</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for PyWFL.statistics</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">_statistics</span>


<div class="viewcode-block" id="aic"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.aic">[docs]</a><span class="k">def</span> <span class="nf">aic</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">residuals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the A (or minimum) Information Criterion (AIC) in order to select the most suitable parameter of polynomial&#39;s order (the minimum AIC order is best)</span>

<span class="sd">    Args:</span>
<span class="sd">        m (int) : The numbers of normal equation (in HARMONIC subroutine m=n)</span>
<span class="sd">        residuals (array) : residuals[n], The standard variation of residual series (different between fit polynomial and original data)</span>
<span class="sd">        max_order (int) : The maximum polynomial order to be fitted</span>


<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * rs (array) : rs[n], the AIC value AIC(q), see algorithm for details</span>
<span class="sd">            * order (int) : The best polynomial fit order under AIC criterion</span>

<span class="sd">    Notes:</span>
<span class="sd">        The fit model is :math:`y(t) = a_i t^{i-1}`, where :math:`i=1,2,\dots` here :math:`i` means :math:`i-1` order polynomial.</span>

<span class="sd">        n is between N/3 to 2N/3 for ARMA time series (N is length of time series)</span>

<span class="sd">        .. math:: AIC(q) = \\log \\left( \\sigma \\right) + 2q/n</span>

<span class="sd">        or</span>

<span class="sd">        .. math:: AIC(q) = n \\log \\left( \\sigma \\right) + 2q</span>

<span class="sd">        where :math:`\\sigma` is standard deviation of residual series, :func:`q` is ARMA model&#39;s order.</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`bic`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_aic</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">residuals</span><span class="p">)</span></div>


<div class="viewcode-block" id="bic"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.bic">[docs]</a><span class="k">def</span> <span class="nf">bic</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">residuals</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the Bayesian extension of the AIC (BIC) in order to select the most suitable parameter of polynomial&#39;s order (the minimum BIC order is best)</span>

<span class="sd">    Args:</span>
<span class="sd">        m (int) : The numbers of normal equation (in HARMONIC subroutine m=n)</span>
<span class="sd">        residuals (array) : residuals[n], The standard variation of residual series (different between fit polynomial and original data)</span>
<span class="sd">        max_order (int) : The maximum polynomial order to be fitted</span>


<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * rs (array) : rs[n], the AIC value AIC(q), see algorithm for details</span>
<span class="sd">            * order (int) : The best polynomial fit order under AIC criterion</span>

<span class="sd">    Notes:</span>
<span class="sd">        The fit model is :math:`y(t) = a_i t^{i-1}`, where :math:`i=1,2,\dots` here :math:`i` means :math:`i-1` order polynomial.</span>

<span class="sd">        n is between N/3 to 2N/3 for ARMA time series (N is length of time series)</span>

<span class="sd">        .. math:: AIC(q) = \\log \\left( \\sigma \\right) + q \\log \\left( n \\right) /n</span>

<span class="sd">        or</span>

<span class="sd">        .. math:: AIC(q) = n \\log \\left( \\sigma \\right) + q \\log \\left( n \\right)</span>

<span class="sd">        where :math:`\\sigma` is standard deviation of residual series, :func:`q` is ARMA model&#39;s order.</span>

<span class="sd">        The difference between :func:`aic` and func:`bic` is the 2nd term of the equation, in func:`bic` use :math:`log(n)` and in :func:`aic` use 2.0. Generally, :func:`log(n)&gt;&gt;2.0`, so the best order got by func:`bic` is less than by :func:`aic`. When n is infinite, the order determined by :func:`aic` is greater than the true order, but the func:`bic` can get the true order.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_bic</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">residuals</span><span class="p">)</span></div>


<div class="viewcode-block" id="chinv"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.chinv">[docs]</a><span class="k">def</span> <span class="nf">chinv</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate Chi-square cumulative distribution functions from given significance level or confidence level and Degrees of Freedom (DOF)</span>

<span class="sd">    Args:</span>
<span class="sd">        alpha (float) : Significance level. alpha typically =0.01,0.05,0.10. Confidence level :math:`p=1-\\alpha \\quad (0.0&lt;p&lt;1.0)`, typically p=0.90, 0.95, 0.99.</span>
<span class="sd">        dof (float) : Degrees of Freedom for Chi-square</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Chi-square value calculated from P and DOF</span>

<span class="sd">    Notes:</span>
<span class="sd">        :func:`chinv` is modified from DCDFLIB: Available at http://www.netlib.org/random/</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_chinv</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dof</span><span class="p">)</span></div>


<div class="viewcode-block" id="cumsum"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.cumsum">[docs]</a><span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;cumulative sum on an array, with optional additive seed</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array) : Array will be  summed cumulatively</span>
<span class="sd">        seed (float) : The add constant of x(1)</span>

<span class="sd">    Return:</span>
<span class="sd">        array : The cumulative sum of array arr, has the same length with x</span>

<span class="sd">    Notes:</span>
<span class="sd">        Given the rank 1 array arr , returns an array of identical type and size containing the cumulative sums of arr. If the optional argument seed is present, it is added to the first component (and therefore, by cumulation, all components) of the result.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; x = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; cumsum(x) # [  1.   3.   6.  10.  15.]</span>
<span class="sd">        &gt;&gt;&gt; cumsum(x, seed=3) # [  4.   6.   9.  13.  18.]</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span></div>


<div class="viewcode-block" id="diff"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.diff">[docs]</a><span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Forward differential for a time series</span>

<span class="sd">    Arg:</span>
<span class="sd">        x (array) : Array x, time series to be forward differential</span>

<span class="sd">    Return:</span>
<span class="sd">        array : [n-1], Forward differential time series</span>

<span class="sd">    Notes:</span>
<span class="sd">        forward differential: :math:`xout_k=x_{k+1}-x_k`</span>
<span class="sd">        backward differential: :math:`xout_k=x_k-x_{k-1}`</span>
<span class="sd">        central differential: :math:`xout_k=x_{k+1}-x_{k-1}`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="geop"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.geop">[docs]</a><span class="k">def</span> <span class="nf">geop</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Arguments</span>

<span class="sd">    Args:</span>
<span class="sd">        first (float) : The first value of geometic progression</span>
<span class="sd">        factor (float) : The factor of geometic progression</span>
<span class="sd">        n (int) : The number of geometic progression</span>

<span class="sd">    Return:</span>
<span class="sd">        array : The array of geometic progression</span>

<span class="sd">    Notes:</span>
<span class="sd">        Returns an array of length n containing a geometric progression whose first value is first and whose multiplier is factor. If first and factor have rank greater than zero, returns an array of one larger rank, with the last subscript having size n and indexing the progression.</span>

<span class="sd">        .. math::</span>
<span class="sd">            geop_1 &amp; = first \\\\</span>
<span class="sd">            geop_k &amp; = geop_{k-1} \dot factor</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_geop</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">factor</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="leap_rm"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.leap_rm">[docs]</a><span class="k">def</span> <span class="nf">leap_rm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">min_leap</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove leap values from a time series</span>

<span class="sd">    Args:</span>
<span class="sd">        x (Array): Time series to be remove leap values</span>
<span class="sd">        zleap_min : The minimum leap values (positive) taken as leap point</span>
<span class="sd">    Return:</span>
<span class="sd">        array : Time series remove leap points and remove averages</span>

<span class="sd">    Notes:</span>
<span class="sd">        Some times, a time series my have some leap (or jump) points, which cause the time series is not continue, so these leap points should be removed from the original field. Then what method should be used to do this? The simple method is to get forward differential first, then check the forward differential values, if the absolute values of forward differential greater than a threshold (here denoted by zleap_min), then we take this point as a leap points. After all leap points are find,  we remove the average between two leap points and get the continue time series.</span>
<span class="sd">        If the two continue points are both leap points, the output data may have leap points too. So in this instance, you must combine the two points as one then use :func:`leap_rm`.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_leap_rm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">min_leap</span><span class="p">)</span></div>


<div class="viewcode-block" id="montonic"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.montonic">[docs]</a><span class="k">def</span> <span class="nf">montonic</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Determine if an array is monotonic</span>

<span class="sd">    Arg:</span>
<span class="sd">        x (array) : Must be a real/double array, one dimensions</span>

<span class="sd">    Return:</span>
<span class="sd">        bool : If True, then the array x is monotonic.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_statistics</span><span class="o">.</span><span class="n">py_monotonic</span><span class="p">(</span><span class="n">x</span><span class="p">))</span></div>


<div class="viewcode-block" id="montecarlo"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.montecarlo">[docs]</a><span class="k">def</span> <span class="nf">montecarlo</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ivars</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Give critical coherence coefficient at different confidential level (90% 95% and 99%) for multi-variables (:math:`\geq 2`)</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Number of data (or Degree of Freedom, DOF=n-ivars ) (n&gt;ivars)</span>
<span class="sd">        ivars (int) : Total variables (ivars&gt;=2)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple : co90, co90s, co95, co95s, co99, co99s</span>
<span class="sd">            * co90, co95, co99 : Critical coherence coefficient of corresponding confidential level (90%,95%,99%)</span>
<span class="sd">            * co90s, co95s, co99s : Standard deviation of co90,co95,co99</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_montecarlo</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ivars</span><span class="o">=</span><span class="n">ivars</span><span class="p">)</span></div>


<div class="viewcode-block" id="month_mean"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.month_mean">[docs]</a><span class="k">def</span> <span class="nf">month_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">total_month</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get monthly average field from daily field</span>

<span class="sd">    Args:</span>
<span class="sd">        x (array) : Daily field to be monthly averaged</span>
<span class="sd">        year (int) : Year for the first data</span>
<span class="sd">        month (int) : Month for the first data</span>
<span class="sd">        total_month (int) : Total monthes for daily field x</span>

<span class="sd">    Return:</span>
<span class="sd">        array: Monthly average field from daily field x</span>

<span class="sd">    Notes:</span>
<span class="sd">        The first data x[0] must be the field of begin day for any month, the last data x[n-1] must be the end day for any month. That means no omit data in any month for daily field. If the begin day or end day do not correspond with the above law, then return errors.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_month_mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">year</span><span class="p">,</span> <span class="n">month</span><span class="p">,</span> <span class="n">total_month</span><span class="p">)</span></div>


<div class="viewcode-block" id="month_mean_idx"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.month_mean_idx">[docs]</a><span class="k">def</span> <span class="nf">month_mean_idx</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">total_month</span><span class="p">,</span> <span class="n">year_begin</span><span class="p">,</span> <span class="n">month_begin</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">month_end</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get monthly field index from daily or sub-month field</span>

<span class="sd">    Args:</span>
<span class="sd">        t (array) : t[n], The time index of original field (at least 2 values in each month), must be monotonic and in unit of Modified Julian Day (MJD).</span>
<span class="sd">        total_month : The number of months between begin and end month (n&gt;2*total_month)</span>
<span class="sd">        year_begin (int) : Begin year (4 digitals)</span>
<span class="sd">        month_beign (int) : Begin month</span>
<span class="sd">        year_end (int) : End year (4 digitals)</span>
<span class="sd">        month_end (int) : End month</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * idx_begin (array) :  idx_begin[total_month], Begin index number of ith month in t</span>
<span class="sd">            * idx_end (array) :  idx_end[total_month], End index number of ith month in t</span>

<span class="sd">    Notes:</span>
<span class="sd">        If we have a field with 10 days interval, we want to get monthly averaged field, what should we do? We know, there are may be 3 or 4 data field in one month, but we do not know exactly in which month we have 3 or 4 data. Then we can find it by MONTH_MEAN_IDX. First, we must have the time index (MJD unit) of 10 days interval field, then we can get the data index (begin and end index) for each month in original field. Now, we can do average easily.  See Example for details.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_month_mean_idx</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">total_month</span><span class="p">,</span> <span class="n">year_begin</span><span class="p">,</span> <span class="n">month_begin</span><span class="p">,</span> <span class="n">year_end</span><span class="p">,</span> <span class="n">month_end</span><span class="p">)</span></div>


<div class="viewcode-block" id="var_percent"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.var_percent">[docs]</a><span class="k">def</span> <span class="nf">var_percent</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate &quot;b can explained variance percent of a &quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        a (array) : array a</span>
<span class="sd">        b (array) : array b,  len(a) == len(b)</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Percent of variance explained by b for a</span>

<span class="sd">    Notes:</span>
<span class="sd">        This subroutine only give the one signal variance percent explained by another signal. Please note, the results maybe mis-interpreted. For example, if a and b are the same cosine function with period 365 days but only different with phase initial.</span>

<span class="sd">        +--------------------+--------------------------------------------+</span>
<span class="sd">        |phase difference    |  variance explained (:func:`var_percent`)  |</span>
<span class="sd">        +--------------------+--------------------------------------------+</span>
<span class="sd">        |:math:`10^\circ`    |         97%                                |</span>
<span class="sd">        +--------------------+--------------------------------------------+</span>
<span class="sd">        |:math:`20^\circ`    |         87%                                |</span>
<span class="sd">        +--------------------+--------------------------------------------+</span>
<span class="sd">        |:math:`30^\circ`    |         71%                                |</span>
<span class="sd">        +--------------------+--------------------------------------------+</span>
<span class="sd">        |:math:`45^\circ`    |         37%                                |</span>
<span class="sd">        +--------------------+--------------------------------------------+</span>
<span class="sd">        |:math:`60^\circ`    |          0%                                |</span>
<span class="sd">        +--------------------+--------------------------------------------+</span>
<span class="sd">        |:math:`90^\circ`    |         -115%                              |</span>
<span class="sd">        +--------------------+--------------------------------------------+</span>

<span class="sd">        If the amplitude are factor: (e.g. b=0.9b, 0.8b, 0.5b), which means different amplitude and 10deg phase difference.</span>

<span class="sd">        +-----------------+-----------------+--------------------------------------------+</span>
<span class="sd">        |phase difference | amplitude factor|  variance explained (:func:`var_percent`)  |</span>
<span class="sd">        +-----------------+-----------------+--------------------------------------------+</span>
<span class="sd">        | :math:`10^\circ`|        0.9      |                  96%                       |</span>
<span class="sd">        +-----------------+-----------------+--------------------------------------------+</span>
<span class="sd">        | :math:`10^\circ`|        0.8      |                  93%                       |</span>
<span class="sd">        +-----------------+-----------------+--------------------------------------------+</span>
<span class="sd">        | :math:`10^\circ`|        0.5      |                  73%                       |</span>
<span class="sd">        +-----------------+-----------------+--------------------------------------------+</span>

<span class="sd">        Thus, the results must be interpreted carefully.</span>

<span class="sd">        The algorithm is:</span>

<span class="sd">            .. math:: varpercent=1-(var(a-b))/var(a))</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; t = np.arange(100)</span>
<span class="sd">        &gt;&gt;&gt; a = np.cos(t) + 0.00002 * t</span>
<span class="sd">        &gt;&gt;&gt; b = 0.25 * a</span>
<span class="sd">        &gt;&gt;&gt; var_percent(a, b) # 43.75%</span>
<span class="sd">        &gt;&gt;&gt; b = a</span>
<span class="sd">        &gt;&gt;&gt; var_percent(a, b) # 100%</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_varpercent</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span></div>


<div class="viewcode-block" id="cdff"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.cdff">[docs]</a><span class="k">def</span> <span class="nf">cdff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dof1</span><span class="p">,</span> <span class="n">dof2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate F cumulative distribution functions from given confidence level P and Degrees of Freedom</span>

<span class="sd">    Args:</span>
<span class="sd">        p (float) : Confidential level P (0.0&lt;P&lt;1.0), typically p=0.90, 0.95, 0.99</span>
<span class="sd">        dof1 (float) : Degrees of freedom of the numerator sum of squares or the first variable.</span>
<span class="sd">        dof2 (float) : Degrees of freedom of the denominator sum of squares or the second variable.</span>

<span class="sd">    Return:</span>
<span class="sd">        float : F cumulative distribution value calculated from p and dof1, dof2.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_wfl_cdff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dof1</span><span class="p">,</span> <span class="n">dof2</span><span class="p">)</span></div>


<div class="viewcode-block" id="cdfnor"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.cdfnor">[docs]</a><span class="k">def</span> <span class="nf">cdfnor</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate Normal (Gauss) cumulative distribution functions from given significance level or confidence level</span>

<span class="sd">    Arg:</span>
<span class="sd">        p (float) : Significance level, typically p=0.90, 0.95, 0.99.</span>

<span class="sd">    Return:</span>
<span class="sd">         float: Normal (Gauss) cumulative distribution value at given significance level</span>

<span class="sd">    Notes:</span>
<span class="sd">        :func:`cdfnor` is modified from DCDFLIB: Available at http://www.netlib.org/random/</span>
<span class="sd">        Normal(1-alpha/2)   where alpha=1-p, and p typically =0.90, 0.95, 0.99</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_wfl_cdfnor</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">)</span></div>


<div class="viewcode-block" id="cdft"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.cdft">[docs]</a><span class="k">def</span> <span class="nf">cdft</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dof</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate Student&#39;s t cumulative distribution functions from given significance level or confidence level and Degrees of Freedom</span>

<span class="sd">    Args:</span>
<span class="sd">        p (float) : Significance level, typically p=0.90, 0.95, 0.99.</span>
<span class="sd">        dof (float) : Degrees of freedom</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Student&#39;s t cumulative distribution value calculated from p and dof.</span>

<span class="sd">    Notes:</span>
<span class="sd">        :func:`cdft` is modified from DCDFLIB: Available at http://www.netlib.org/random/</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">p</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_wfl_cdft</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">dof</span><span class="p">)</span></div>


<div class="viewcode-block" id="taylor_diagram"><a class="viewcode-back" href="../../PyWFL.statistics.html#PyWFL.statistics.taylor_diagram">[docs]</a><span class="k">def</span> <span class="nf">taylor_diagram</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">isnormal</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get Taylor diagram parameters</span>

<span class="sd">    Args:</span>
<span class="sd">        r(n) : the reference time series</span>
<span class="sd">        f(n) : the model time series</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : out[6], output Taylor diagram parameter.</span>

<span class="sd">            * out(1:3)==&gt;standard deviation (std) of r(n), std of f(n), correlation coefficient between r(n) and f(n) == cos(fai)</span>
<span class="sd">            * out(4:6)==&gt;E&#39; (centered RMS difference), sigma_f*cos(fai)== x value in plot, sigma_f*sin(fai)== y value in plot</span>

<span class="sd">    Notes:</span>
<span class="sd">        out(1)=std_n(r) !standard deviation by use std_n subroutine</span>
<span class="sd">        out(2)=std_n(f)</span>
<span class="sd">        out(3)=cor2(r,f) !correlation coefficient by use cor2 subrotine</span>
<span class="sd">        out(4)**2=out(1)**2+out(2)**2-2*out(1)*out(2)*out(3)</span>
<span class="sd">        out(5)=out(2)*cos(fai)  !cos(fai)==out(3), x coordiante used by Taylor.diagram.bas for plotting in Grapher10</span>
<span class="sd">        out(6)=out(2)*sin(fai)   ! y coordinate used by  Taylor.diagram.bas for plotting in Grapher10</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Taylor K. E., Summarizing multiple aspects of model performance in a single diagram, J. Geophys. Res., Vol.106, P7183-7192,2001.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">isnormal</span> <span class="o">=</span> <span class="s1">&#39;y&#39;</span> <span class="k">if</span> <span class="n">isnormal</span> <span class="k">else</span> <span class="s1">&#39;n&#39;</span>
    <span class="k">return</span> <span class="n">_statistics</span><span class="o">.</span><span class="n">py_wfl_taylor_diagram</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">isnormal</span><span class="o">=</span><span class="n">isnormal</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, YAN Haoming, WU Dingcheng.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>