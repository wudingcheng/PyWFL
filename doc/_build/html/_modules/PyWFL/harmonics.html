

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyWFL.harmonics &mdash; PyWFL 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyWFL 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="PyWFL" href="../PyWFL.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PyWFL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">PyWFL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">PyWFL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../PyWFL.html">PyWFL</a> &raquo;</li>
      
    <li>PyWFL.harmonics</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for PyWFL.harmonics</h1><div class="highlight"><pre>
<span></span><span class="c1"># encoding: utf-8</span>
<span class="kn">import</span> <span class="nn">_harmonics</span>


<div class="viewcode-block" id="cs2k"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.cs2k">[docs]</a><span class="k">def</span> <span class="nf">cs2k</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">quantum</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change real spherical harmonic coefficients to complex spherical harmonic coefficients.</span>

<span class="sd">    Args:</span>
<span class="sd">        c (array) : c[n, n], Coefficients of cosine term</span>
<span class="sd">        s (array) : s[n, n], Coefficients of sine term</span>
<span class="sd">        quantum (bool) : default True, then the subroutine will return the fully normalized complex coefficients usually used in quantum mechanics domain; if quantum is False, then the subroutine will return the complex coefficients corresponding to c and s. See algorithm for details.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : k[n, 0:2n-1], Complex coefficients of c and s</span>

<span class="sd">    Note:</span>
<span class="sd">        here c and s are get from subroutine FUNC_EXP_FFT</span>

<span class="sd">        if quantum is False, then:</span>

<span class="sd">            .. math::</span>
<span class="sd">                \\left ( 2 - \\delta_m \\right ) K_{n,m} = C_{n, m} - i S_{n, m} \\quad m \\geq 0, \\left\\{\\begin{matrix} \\delta = 1.0, m \\neq 0 \\\\ \\delta = 2.0, m = 0  \\end{matrix}\\right. \\\\</span>
<span class="sd">                K_{n, -m} = (-1)^m conjg(K_{n, m}) \\quad m &gt; 0</span>


<span class="sd">        if quantum is True, then:</span>

<span class="sd">            .. math::</span>
<span class="sd">                K_{n,m} &amp; = &amp; -1^m \\sqrt{4 \\pi} \\left (c_{nm} + is_{nm} \\right ) /  \\sqrt{2 - \\delta_m} \\quad m \\geq 0 \\\\</span>
<span class="sd">                k_{n,-m} &amp; = &amp; -1^m conjgK_{n, m}, \\quad m &gt; 0</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; c = np.array([[1.2, 0, 0], [2.4, 3.2, 0], [0.9, 0.8, 9.8]])</span>
<span class="sd">        &gt;&gt;&gt; s = np.zeros((3, 3))</span>
<span class="sd">        &gt;&gt;&gt; cs2k(c, s).shape</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cha</span> <span class="o">=</span> <span class="s1">&#39;quantum&#39;</span> <span class="k">if</span> <span class="n">quantum</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_cs2k</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="n">cha</span><span class="p">)</span></div>


<div class="viewcode-block" id="cs2kai"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.cs2kai">[docs]</a><span class="k">def</span> <span class="nf">cs2kai</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change degree 2 spherical harmonic (Stokes) coefficients of the gravity field (C20,C21,S21) to polar motion and length of day (LOD) domain</span>

<span class="sd">    Args:</span>
<span class="sd">        cs (float) : One of the degree 2 spherical harmonic (Stokes) coefficients of the gravity field (C20 or C21 or S21)  (cs is fully normalized spherical harmonic coefficients, like get from :func:`func_exp_fft`)</span>
<span class="sd">        cha (string) : cha is one of follow character, &#39;X&#39;,  &#39;Y&#39; , &#39;Z&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: Polar Motion (unit: mas) or Length of Day (unit: ms)</span>

<span class="sd">    Notes</span>
<span class="sd">        the transfer pairs are (C20, LOD), (C21, POLAR MOTION X),(S21, POLAR MOTION Y),  and only mass term suit to use this function.</span>

<span class="sd">        mas=milli-arcsencod, ms=millisecond</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Yan Haoming, The role of ocean in Earth&#39;s Rotation and Gravity field, Doctor thesis, Wuhan, 2005.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cha should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conds</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_cs2kai</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">cha</span><span class="p">)</span></div>


<div class="viewcode-block" id="pn"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.pn">[docs]</a><span class="k">def</span> <span class="nf">pn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the Legendre Polynomials Pn(x) using recursion relation equation</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Maximum degree of Legendre polynomials :math:`P_{n}(x)`</span>
<span class="sd">        x (float) : In general, :math:`x = \cos \theta`, :math:`|x| \leq 1`</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : pnx[n], Value of :math:`P_{n}(x)`</span>

<span class="sd">    Notes:</span>
<span class="sd">        http://www.efunda.com/math/legendre/index.cfm for more details.</span>
<span class="sd">        This subroutine is modified from a Fortran77 function provided by Dr. Wang Hansheng (汪汉胜).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from numpy import cos, pi</span>
<span class="sd">        &gt;&gt;&gt; pn(5, cos(pi / 3))</span>

<span class="sd">    See Also:</span>
<span class="sd">        pn_diff</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_wfl_pn</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="pn_diff"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.pn_diff">[docs]</a><span class="k">def</span> <span class="nf">pn_diff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the one order derivative of Legendre Polynomials Pn(x) using recursion relation equation. The results are :math:`dP_{n}(\\cos \\theta / d\\theta)`, where :math:`x = \\cos \\theta`, :math:`-1 \\ leq x \\leq 1`</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Maximum degree of Legendre polynomials :math:`P_{n}(x)`</span>
<span class="sd">        x (float) : In general, :math:`x = \\cos \\theta`, :math:`|x| \\leq 1`</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : pndiff[n], Value of :math:`dP_{n}(x) / d\\theta`</span>

<span class="sd">    Notes:</span>
<span class="sd">        http://www.efunda.com/math/legendre/index.cfm for more details.</span>
<span class="sd">        This subroutine is modified from a Fortran77 function provided by Dr. Wang Hansheng (汪汉胜).</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from numpy import cos, pi</span>
<span class="sd">        &gt;&gt;&gt; pn_diff(5, cos(pi / 3))</span>

<span class="sd">    See Also:</span>
<span class="sd">        pn</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_wfl_pn_diff</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>


<div class="viewcode-block" id="pnm"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.pnm">[docs]</a><span class="k">def</span> <span class="nf">pnm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get fully normalized associated Legendre function :math:`P_{nm}(\\cos \\theta)`</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Maximum order number of fully normalized associated Legendre function (:math:`n \geq 1`),</span>
<span class="sd">        theta (float) : :math:`\\theta`, co-latitude in degree unit (:math:`0^{\circ}-180^{\circ}`)</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray : p[n+1,n+1], Fully normalized (:math:`4\pi`) associated Legendre function :math:`P_{nm}(\cos \\theta)`</span>


<span class="sd">    Notes:</span>
<span class="sd">        The best maximum order n for PNM is 1080. If n&gt;1080, the error will increase. Check precision formula is:</span>

<span class="sd">            .. math:: \\sum_{m=0, n} \\left ( P_{nm} \\right)^2 = 2n + 1</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; from numpy import pi, sin, cos, sqrt</span>
<span class="sd">        &gt;&gt;&gt; theta = pi / 3</span>
<span class="sd">        &gt;&gt;&gt; pnm(2, 60)</span>
<span class="sd">        &gt;&gt;&gt; res = pnm(3, 60)</span>
<span class="sd">        &gt;&gt;&gt; sqrt(5) * (3 * cos(pi / 3) ** 2 - 1) / 2 # res[2, 0]</span>
<span class="sd">        &gt;&gt;&gt; sqrt(15) * cos(pi / 3) * sin(np.pi / 3) # res[2, 1]</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_pnm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="pnmi"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.pnmi">[docs]</a><span class="k">def</span> <span class="nf">pnmi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate :math:`\\int P_{nm}\\left (\\cos \\theta \\right ) \\sin \\theta d\\theta|_{ts}^{tn}`</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Maximum order number of fully normalized associated Legendre function (n&gt;=1)</span>
<span class="sd">        ts (float) : Southern co-latitude (:math:`0^{\circ}-180^{\circ}`)</span>
<span class="sd">        tn (float) : Northern co-latitude (:math:`0^{\circ}-180^{\circ}`), ts&gt;tn (such as 35°,30° which means latitude 55° and 60°)</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray: pinmsn[n+1, n+1]</span>

<span class="sd">    Notes:</span>
<span class="sd">        The maximum order n for PNMI is 1080. If n&gt;1080, the error will increase quickly. Check precision formula is:</span>
<span class="sd">            PNMI(ts,t) + PNMI(t,tn) = PNMI(ts,tn) where ts &lt; t &lt;tn</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; pnmi(3, 40, 30)</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_pnmi</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="n">tn</span><span class="p">)</span></div>


<div class="viewcode-block" id="func_exp_fft"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.func_exp_fft">[docs]</a><span class="k">def</span> <span class="nf">func_exp_fft</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">cord_lon</span><span class="p">,</span> <span class="n">cord_lat</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">iterative</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Expand a global function (such as ocean function) to spherical harmonic coefficients (with iterative refinements).</span>

<span class="sd">    Args:</span>
<span class="sd">        func (array) : Input function (values in grid center) North-&gt;South direction in latitude</span>
<span class="sd">        cord_lon (array) : Longitude coordinate at lattice (unit: degree 0~360 )</span>
<span class="sd">        cord_lat (array) : Latitude coordinate at lattice (unit: degree 90~-90),must be sort from north to</span>
<span class="sd">        n (int) : Maximum spherical harmonic coefficients degree when expand function</span>
<span class="sd">        cha (bool) : default False, if True, then a smoothing operator is used for all the output spherical harmonic coefficients c and s. Using smoothing operator can get better coefficients approximation for the grid point value. If cha is False, then no smoothing operator is used. Then all the spherical harmonic coefficients c and s are the coefficients for mean block values (not grid point value) of the global function func.</span>
<span class="sd">        iterative (int) : default 1; iterative refinements of the results c and s.  If iterative=1, then do once iterative refinements. if iterative=0, then do not do iterative refinements. if iterative equal other number (such as k), then do k times iterative refinements. In general, iterative=1 is enough; but a second call (iterative=2) to verify convergence can be reassuring.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * c (*array*) : Coefficients of cosine term</span>
<span class="sd">            * s (*array*) : Coefficients of sine term</span>
<span class="sd">            * diff_percent (float) : Different percent(%) between integrals of f(q,l)2 in the sphere and the sum of K2 (complex harmonic coefficients get from c and s by using subroutine CS2K). If diff_percent is very small, it denotes the coefficients expanded from func are best.</span>

<span class="sd">    Notes:</span>
<span class="sd">        func_exp_fft has a high speed by using FFT method, and with the iterative refinements and using Parseval theorem to check how much precision of the spherical harmonic coefficients are expanded.</span>
<span class="sd">        The maximum order n for func_exp_fft is 1800. if n &gt; 1800, the error will increase quickly.</span>
<span class="sd">        &gt; There&#39;s some differences for spherical harmonic coefficients c and s between using smoothing operator and not using smoothing operator.</span>
<span class="sd">        When expand a global function to spherical harmonic coefficients,  the maximum degree is 180/grid intervals (e.g. for 1*1 degree grid, the maximum degree is 180, but for 2.5*2.5 degree grid, the maximum degree is 72).</span>
<span class="sd">        All spherical harmonic coefficients are fully normalized (see algorithm for details).</span>

<span class="sd">        The definition of the un-normalized Associated Legendre Polynomial is then</span>

<span class="sd">        .. math::</span>
<span class="sd">            P_{lm}(x) = \\frac{(1 - x^2)^{m/2}}{2^n n!} \\frac{d^{l+m}}{dx^{l+m}}[(x^2 - 1)^n]</span>

<span class="sd">        If the normalization factor is defined such that</span>

<span class="sd">        .. math::</span>
<span class="sd">            N_{lm}^2 = \\sqrt{\\frac{(2 - \\delta_{m0})(2l + 1)(l - m)!}{(l + m)!}}</span>

<span class="sd">        and the Associated Legendre Polynomials are normalized by</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\bar{P}_{lm} = N_{lm} P_{lm}</span>

<span class="sd">        then, over a unit sphere :math:`S`</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\iint_{S}\\left[ \\bar{P}_{lm}(\\sin \\varphi ) \\begin{Bmatrix} \\cos m\\lambda \\\\ \\sin m\\lambda \\end{Bmatrix}\\right]^2 ds = 4 \\pi</span>

<span class="sd">        In this convention, the relationship of the spherical harmonic coefficients to the mass distribution function f (or any function) becomes</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\begin{Bmatrix} \\bar{C}_{lm} \\\\ \\bar{S}_{lm} \\end{Bmatrix}\\ = \\frac{1}{4\\pi} \\iint_S f(\\theta, \\lambda) \\bar{P}_{lm}(\\sin \\varphi)\\begin{Bmatrix} \\cos m\\lambda \\\\ \\sin m\\lambda \\end{Bmatrix}ds</span>


<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Andre Mainvile,The Altimetry-Gravimetry Problem Using Orthonormal Base Functions, Report No. 373, Department of Geodetic Science and Surveying, the Ohio State University, 1986.</span>
<span class="sd">        .. [2] Paul M. K., Recurrence Relations For Integrals Of Associated Legendre Functions, Bulletin Geodesique, VOL.52, P177-190,1978.</span>
<span class="sd">        .. [3] Wunsch C, and D. Stammer, The global frequency-wavenumber spectrum of oceanic variability estimated from TOPEX/Poseidon altimetric measurements, J. Geophys. Res., Vol.100, NO. C12, P24895-24910, 1995.  (Eq. 2)</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cha</span> <span class="o">=</span> <span class="s1">&#39;smooth&#39;</span> <span class="k">if</span> <span class="n">smooth</span> <span class="k">else</span> <span class="s1">&#39;no&#39;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_wfl_func_exp_fft</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">cord_lon</span><span class="p">,</span> <span class="n">cord_lat</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="n">cha</span><span class="p">,</span> <span class="n">iterative</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnm"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.dpnm">[docs]</a><span class="k">def</span> <span class="nf">dpnm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get first order derivatives of fully normalized associated Legendre function :math:`dP_{nm}(\cos \\theta)/d\\theta`</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Maximum degree of fully normalized associated Legendre function (n&gt;=1)</span>
<span class="sd">        theta (float) : Co-latitude in degree unit (0-180).</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : First order derivatives of fully normalized (:math:`4\pi`) associated Legendre function :math:`dP_{nm}(\cos \\theta)/d\\theta` or :math:`P_{nm}^{&#39;}`</span>

<span class="sd">    Notes:</span>
<span class="sd">        See FUNC_EXP for definition of fully normalized Legendre function.</span>
<span class="sd">        check value: see example for this subroutine checking.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Rummel R, van Gelderen M, Koop R, Schrama E, Sanso` F, Brovelli M, Miggliaccio F, Sacerdote F (1993) Spherical harmonic analysis of satellite gravity gradiometry. Publications on Geodesy, New series, no. 39. Netherlands Geodetic Commission, Delft.  Appendix A-2 (Note, some equations in A-2 have misprints).</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_wfl_dpnm</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="dpnm2"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.dpnm2">[docs]</a><span class="k">def</span> <span class="nf">dpnm2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get first and second order derivatives of fully normalized associated Legendre function :math:`dP_{nm}(\cos \\theta)/d\\theta`, :math:`d^{2}P_{nm}(\cos \\theta)/d\\theta^2)`</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Maximum degree of fully normalized associated Legendre function (n&gt;=1)</span>
<span class="sd">        theta (float) : Co-latitude in degree unit (0-180).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * :math:`P_{nm}^{&#39;}` (array) : First order derivatives of fully normalized (:math:`4\pi`) associated Legendre function :math:`dP_{nm}(\cos \\theta)/d\\theta` or :math:`P_{nm}^{&#39;}`</span>
<span class="sd">            * :math:`P_{nm}^{&#39;&#39;}` (array) : Second order derivatives of fully normalized (:math:`4\pi`) associated Legendre function :math:`dP_{nm}^{2}(\cos \\theta)/d\\theta^{2}` or :math:`P_{nm}^{&#39;&#39;}`</span>

<span class="sd">    Notes:</span>
<span class="sd">        See FUNC_EXP for definition of fully normalized Legendre function.</span>
<span class="sd">        check value: see example for this subroutine checking.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Rummel R, van Gelderen M, Koop R, Schrama E, Sanso` F, Brovelli M, Miggliaccio F, Sacerdote F (1993) Spherical harmonic analysis of satellite gravity gradiometry. Publications on Geodesy, New series, no. 39. Netherlands Geodetic Commission, Delft.  Appendix A-2 (Note, some equations in A-2 have misprints).</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_wfl_dpnm2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span></div>


<div class="viewcode-block" id="func_sum_fft"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.func_sum_fft">[docs]</a><span class="k">def</span> <span class="nf">func_sum_fft</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cmethod</span><span class="o">=</span><span class="s1">&#39;p&#39;</span><span class="p">,</span> <span class="n">depart_lon</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get function point or mean value from spherical harmonic coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">        lon (int) : Number of longitude (center grid number)</span>
<span class="sd">        lat (array) : Latitude coordinate (any begin value (such as 88.6 in the first grid) and regular grid after the first one (such as 86.1,83.6,... for 2.5 degree grid), when point is True;  must be grid center latitude when point is False) (unit: degree 90~-90, direction North--&gt;South )</span>
<span class="sd">        c (array) : c[n], Coefficients of cosine term</span>
<span class="sd">        s (array) : s[n], Coefficients of sine term</span>
<span class="sd">        point (boolean) : default True, then output function point value at longitude and latitude intersection; when False, then output mean function value at each grid block. See comment and algorithm in below for details.</span>
<span class="sd">        cmethod (string): default &#39;p&#39;, means ... optional in [&#39;p&#39;, &#39;dp&#39;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : val[nlon, nlat], Function value at global grid points</span>

<span class="sd">    Notes:</span>
<span class="sd">        There&#39;s some differences for point value and mean value, see Andre Mainvile (1986) for details.</span>
<span class="sd">        When expand a global function to spherical harmonic coefficients,  the maximum degree is 180/grid intervals (e.g. for 1*1 degree grid, the maximum degree is 180, but for 2.5*2.5 degree grid, the maximum degree is 72). But from spherical harmonic coefficients to get global function values, we can meet 3 cases like below:</span>

<span class="sd">            1. the maximum degree = function grid (2*N=LON), e.g. from 72 degree coefficients to get 2.5*2.5 degree (LON=144) global function value</span>
<span class="sd">            2. the maximum degree &lt; function grid (2*N&lt;LON), e.g. from 72 degree coefficients to get 1.25*1.25 degree (LON=288) global function value</span>
<span class="sd">            3. the maximum degree &gt; function grid (2*N&gt;LON),  e.g. from 72 degree coefficients to get 5*5 degree (LON=72) global function value</span>

<span class="sd">        All the above case can be solved by FUNC_SUM_FFT . The first one is exact, but the last two cases interpolate global function values from coefficients domain, which likes to interpolate in frequency domain and then go back to temporal domain. So be careful to use the last two cases.</span>

<span class="sd">        All spherical harmonic coefficients are fully normalized (see FUNC_EXP for details).</span>

<span class="sd">        FUNC_SUM uses the popular method to calculate a function point value from spherical harmonic coefficients, but FUNC_SUM_FFT uses the most fast fourier transform method when calculate a function&#39;s grid value and mean value, so FUNC_SUM_FFT is more speed than FUNC_SUM. In my computer (2.0G CPU, 512Mb RAM, Windows2000, VISUAL FORTRAN 6.5), the speed of FUNC_SUM_FFT is about n (the maximum degree of coefficients) times quickly than FUNC_SUM and same precision for the coefficients. So the best choice is to use FUNC_SUM_FFT, but not FUNC_SUM.</span>


<span class="sd">        All coefficients are normalized (see FUNC_EXP for most comments):</span>

<span class="sd">            .. math:: \\begin{Bmatrix} \\bar{C}_{lm} \\\\ \\bar{S}_{lm} \\end{Bmatrix} = \\frac{1}{4\\pi} \\iint_{S} f(\\theta, \\lambda) \\bar{p}_{lm}(\\sin \\phi) \\begin{Bmatrix} \\cos m\\lambda \\\\ \\sin m\\lambda \\end{Bmatrix} ds</span>

<span class="sd">        For Point value:</span>

<span class="sd">            .. math:: F_{ij} = \\sum_{n=0}^{N} \\sum_{m=0}^{n} \\left( C_{nm} \\cos m \\lambda_j + S_{nm} \\sin m \\lambda_j \\right) \\bar{P}_nm(\\cos \\theta_i)</span>

<span class="sd">        For mean value:</span>

<span class="sd">            .. math::</span>
<span class="sd">                F_{ij} &amp; = &amp; \\sum_{n=0}^{N} \\sum_{m=0}^{n} \\left( C_{nm} \\cos m \\lambda_j + S_{nm} \\sin m \\lambda_j \\right) \\bar{P}_nm(\\cos \\theta_i) \\\\</span>
<span class="sd">                \\Delta_{ij} &amp; = &amp; \\Delta \\lambda \\left [ \\cos \\theta_i - \\cos \\theta_{i+1} \\right ] \\\\</span>
<span class="sd">                \\bar{I}_{nm}^{i}(\\theta) &amp; = &amp; \\int_{\\theta_i}^{\\theta_{i+1}}\\bar{P}_{nm}\\left ( \\cos \\theta \\right ) \\sin \\theta d\\theta \\\\</span>
<span class="sd">                J_{m}^{i}(\\lambda) &amp; = &amp; \\int_{\\lambda_j}^{\\lambda_{j+1}} \\cos m\\lambda d\\lambda = \\frac{1}{m}\\sin \\left ( m\\lambda \\right )|_{j\\Delta \\lambda}^{(j+1) \\Delta \\lambda} \\\\</span>
<span class="sd">                K_m^{i}(\\lambda) &amp; = &amp; \\int_{\\lambda_j}^{\\lambda_{j+1}}\\sin m\\lambda d\\lambda = \\frac{-1}{m} \\cos( m\\lambda) |_{j \\Delta \\lambda}^{(j+1)\\Delta \\lambda}</span>

<span class="sd">        Example:</span>
<span class="sd">            todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cha</span> <span class="o">=</span> <span class="s1">&#39;point&#39;</span> <span class="k">if</span> <span class="n">point</span> <span class="k">else</span> <span class="s1">&#39;mean&#39;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_func_sum_fft</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">depart_lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="n">cha</span><span class="p">,</span> <span class="n">cmethod</span><span class="o">=</span><span class="n">cmethod</span><span class="p">)</span></div>


<div class="viewcode-block" id="func_sum"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.func_sum">[docs]</a><span class="k">def</span> <span class="nf">func_sum</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cmethod</span><span class="o">=</span><span class="s1">&#39;p&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get function point value at grid intersection from harmonic coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">        lon (array) : lon[nlon], Longitude coordinate at grid lattice or center or between both (unit: degree 0~360 )</span>
<span class="sd">        lat (array) : lat[nlat], Latitude coordinate at grid lattice or center or between both (unit: degree 90~-90 )</span>
<span class="sd">        c (array) : c[n], Coefficients of cosine term</span>
<span class="sd">        s (array) : s[n], Coefficients of sine term</span>
<span class="sd">        cmethod (string): default &#39;p&#39;, means ... optional in [&#39;p&#39;, &#39;dp&#39;]</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : val[nlon, nlat], Function value at global grid points</span>

<span class="sd">    Notes:</span>
<span class="sd">        The maximum order n for FUNC_SUM/FUNC_SUM_FFT is 1800. If n&gt;1800, the error will increase quickly.</span>

<span class="sd">        func_sum use popular method (see algorithm for details), so the speed of func_sum is slow, you&#39;d better to using func_sum_fft to get the same precision results but most fast in speed.</span>

<span class="sd">        All coefficients are normalized (see func_exp for most comments):</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\begin{Bmatrix} \\bar{C}_{lm} \\\\ \\bar{S}_{lm} \\end{Bmatrix} = \\frac{1}{4\\pi} \\iint_{S} f(\\theta, \\lambda) \\bar{p}_{lm}(\\sin \\phi) \\begin{Bmatrix} \\cos m\\lambda \\\\ \\sin m\\lambda \\end{Bmatrix} ds \\\\</span>
<span class="sd">            F_{ij} = \\sum_{n=0}^{N} \\sum_{m=0}^{n} \\left( C_{nm} \\cos m \\lambda_j + S_{nm} \\sin m \\lambda_j \\right) \\bar{P}_nm(\\cos \\theta_i)</span>

<span class="sd">    See Also:</span>
<span class="sd">        func_sum_fft</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_func_sum</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cmethod</span><span class="o">=</span><span class="n">cmethod</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span></div>


<div class="viewcode-block" id="harmonic"><a class="viewcode-back" href="../../PyWFL.harmonics.html#PyWFL.harmonics.harmonic">[docs]</a><span class="k">def</span> <span class="nf">harmonic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">pdef</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">itrend</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">timebegin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;aic&#39;</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">timebegin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">timebegin</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">pdef</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_wfl_harmonic</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">itrend</span><span class="o">=</span><span class="n">itrend</span><span class="p">,</span> <span class="n">timebegin</span><span class="o">=</span><span class="n">timebegin</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_harmonics</span><span class="o">.</span><span class="n">py_wfl_harmonic_more</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">periods</span><span class="p">,</span> <span class="n">pdef</span><span class="p">,</span> <span class="n">itrend</span><span class="o">=</span><span class="n">itrend</span><span class="p">,</span> <span class="n">timebegin</span><span class="o">=</span><span class="n">timebegin</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, YAN Haoming, WU Dingcheng.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>