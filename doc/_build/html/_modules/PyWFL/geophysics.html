

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyWFL.geophysics &mdash; PyWFL 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="PyWFL 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="PyWFL" href="../PyWFL.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PyWFL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">PyWFL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">PyWFL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
          <li><a href="../PyWFL.html">PyWFL</a> &raquo;</li>
      
    <li>PyWFL.geophysics</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for PyWFL.geophysics</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">_geophysics</span>


<div class="viewcode-block" id="am2eam"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.am2eam">[docs]</a><span class="k">def</span> <span class="nf">am2eam</span><span class="p">(</span><span class="n">am</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="s1">&#39;xp&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Change Angular Momentum (AM) to Effective Angular Momentum (EAM)</span>

<span class="sd">    Args:</span>
<span class="sd">        am (float) : Angular Momentum (unit: :math:`kg.m^2/s`)</span>
<span class="sd">        cha (string) : cha eaqual one of follow character, &#39;xp&#39;, &#39;xc&#39;, &#39;yp&#39;, &#39;yc&#39;, &#39;zp&#39;, &#39;zc&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        float : Effective Angular Momentum (unit: 1.0e-7 rad)</span>

<span class="sd">    Notes:a</span>
<span class="sd">        cha denote x,y or z coordinate for pressure (p) and current (c) term</span>
<span class="sd">        All the parameters about Earth is Eubank&#39;s value like below:</span>

<span class="sd">            &gt;&gt;&gt; cc  = 7.1236 #earth principal moment of inertia</span>
<span class="sd">            &gt;&gt;&gt; ccm = 7.1236</span>
<span class="sd">            &gt;&gt;&gt; ca  = 0.003664*cc       #c - a</span>

<span class="sd">        barnes&#39;s earth parameter (not used here) :</span>

<span class="sd">            &gt;&gt;&gt; cc=7.04</span>
<span class="sd">            &gt;&gt;&gt; ccm=7.1236</span>
<span class="sd">            &gt;&gt;&gt; ca=0.00333*cc</span>

<span class="sd">        this function only used in earth rotation domain, which change oceanic am to oceanic eam.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Barnes R. T. H., Atmospheric angular momentum fluctuations, length of day changes and polar motion, Proc. R. Soc. Lond. A, 387,31-73, 1983.</span>

<span class="sd">    See Also:</span>
<span class="sd">        todo</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xp&#39;</span><span class="p">,</span> <span class="s1">&#39;xc&#39;</span><span class="p">,</span> <span class="s1">&#39;yp&#39;</span><span class="p">,</span> <span class="s1">&#39;yc&#39;</span><span class="p">,</span> <span class="s1">&#39;zp&#39;</span><span class="p">,</span> <span class="s1">&#39;zc&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cond</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_am2eam</span><span class="p">(</span><span class="n">am</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="n">cha</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span></div>


<div class="viewcode-block" id="geo_distance"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.geo_distance">[docs]</a><span class="k">def</span> <span class="nf">geo_distance</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span> <span class="n">lambda1</span><span class="p">,</span> <span class="n">phi2</span><span class="p">,</span> <span class="n">lambda2</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="s1">&#39;angle&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate geocentric angle (or corresponding Earth&#39;s surface distance) between two points</span>

<span class="sd">    Args:</span>
<span class="sd">        phi1 (float) : First point&#39;s coordinate latitude, unit: degree, -90~90</span>
<span class="sd">        lambda1 (float) : First point&#39;s coordinate longitude, unit: degree, 0~360</span>
<span class="sd">        phi2 (float) : Second point&#39;s coordinate latitude, unit: degree, -90~90</span>
<span class="sd">        lambda2 (float) : Second point&#39;s coordinate longitude unit: degree, 0~360</span>
<span class="sd">        ch (string) : default angle, should be in [&#39;angle&#39;, &#39;distance&#39;], unit radian or meter</span>

<span class="sd">    Returns:</span>
<span class="sd">        float : Geocentric angle (unit: radian) or corresponding Earth&#39;s surface distance (unit: meter).</span>

<span class="sd">    Notes:</span>
<span class="sd">        .. math::</span>
<span class="sd">            \\cos(\\phi) = \\cos( \\theta_1) * \\cos(\\theta_2) + \\sin(\\theta_1) * \\sin(\\theta_2) * \\cos(\\lambda_1 - \\lambda_2)</span>

<span class="sd">        :math:`\\phi` is geocentric angle between two points, and :math:`\\theta_1`,:math:`\\theta_2` are colatitude of :math:`\\phi_1` and :math:`\\phi_2` respectively.</span>
<span class="sd">        The Earth&#39;s radius adopted here is 6371012m.</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>

    <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ch should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cond</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">geo_distance</span><span class="p">(</span><span class="n">phi1</span><span class="p">,</span> <span class="n">lambda1</span><span class="p">,</span> <span class="n">phi2</span><span class="p">,</span> <span class="n">lambda2</span><span class="p">,</span> <span class="n">ch</span><span class="p">)</span></div>


<div class="viewcode-block" id="area"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.area">[docs]</a><span class="k">def</span> <span class="nf">area</span><span class="p">(</span><span class="n">dlon</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate the grid area of the Earth&#39;s surface</span>

<span class="sd">    Args:</span>
<span class="sd">        dlon (float) :Longitude interval (or length) of the grid (unit: degree)</span>
<span class="sd">        lat1 (float) :Co-latitude of northern grid border (0 represents Northern Pole, and 180  represents Southern Pole, unit: degree)</span>
<span class="sd">        lat2 (float) :Co-latitude of southern grid border (lat2&gt;lat1)</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Area of grid at the Earth&#39;s surface (unit: m**2)</span>

<span class="sd">    Notes:</span>
<span class="sd">        .. math::  ds=r^2 \\sin( \\theta )d( \\theta )d(\\lambda)</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>

    <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_area</span><span class="p">(</span><span class="n">dlon</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">)</span></div>


<div class="viewcode-block" id="cs2kai"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.cs2kai">[docs]</a><span class="k">def</span> <span class="nf">cs2kai</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Change degree 2 spherical harmonic (Stokes) coefficients of the gravity field (C20,C21,S21) to polar motion and length of day (LOD) domain</span>

<span class="sd">    Args:</span>
<span class="sd">        cs (float) : One of the degree 2 spherical harmonic (Stokes) coefficients of the gravity field (C20 or C21 or S21)  (cs is fully normalized spherical harmonic coefficients, like get from FUNC_EXP_FFT)</span>
<span class="sd">        cha (string) : cha is one of follow character, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Polar Motion (unit: mas) or Length of Day (unit: ms)</span>

<span class="sd">    Notes:</span>
<span class="sd">        the transfer pairs are (C20, LOD), (C21, POLAR MOTION X),(S21, POLAR MOTION Y), and only mass term suit to use this function.</span>
<span class="sd">        mas=milli-arcsencod, ms=millisecond</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Yan Haoming, The role of ocean in Earth&#39;s Rotation and Gravity field, Doctor thesis, Wuhan, 2005.</span>


<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        kai2cs</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cond</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_cs2kai</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">cha</span><span class="p">)</span></div>


<div class="viewcode-block" id="kai2cs"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.kai2cs">[docs]</a><span class="k">def</span> <span class="nf">kai2cs</span><span class="p">(</span><span class="n">kai</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change polar motion and length of day (LOD) domain to degree 2 spherical harmonic (Stokes) coefficients of the gravity field (C20,C21,S21)</span>


<span class="sd">    Args:</span>
<span class="sd">        kai (float) : Polar Motion (unit: mas) or Length of Day (unit: ms)</span>
<span class="sd">        cha (string) : cha is one of follow character, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;</span>

<span class="sd">    Return:</span>
<span class="sd">        float : One of the degree 2 spherical harmonic (Stokes) coefficients of the gravity field (C20 or C21 or S21)  (c20,c21,s21 are fully normalized spherical coefficients; the fully normalized (4*pi) Legendre polynomials)</span>

<span class="sd">    Notes:</span>
<span class="sd">        The transfer pairs are (LOD,C20 ), ( POLAR MOTION X,C21),(POLAR MOTION Y, S21), and only mass term are suit to use this function.</span>
<span class="sd">        mas=milli-arcsencod, ms=millisecond</span>
<span class="sd">        when convert LOD to c20, we don&#39;t consider the global mass change (in other words, we set :math:`\Delta M=0`)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Yan Haoming, The role of ocean in Earth&#39;s Rotation and Gravity field, Doctor thesis, Wuhan, 2005.</span>


<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        cs2kai</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cond</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_kai2cs</span><span class="p">(</span><span class="n">kai</span><span class="p">,</span> <span class="n">cha</span><span class="p">)</span></div>


<div class="viewcode-block" id="degree_var"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.degree_var">[docs]</a><span class="k">def</span> <span class="nf">degree_var</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get degree variance from spherical harmonic coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">        c (array) : c(0:n,0:n) Spherical harmonic coefficients (coefficients for cosine term)</span>
<span class="sd">        s (array) : s(0:n,0:n) Spherical harmonic coefficients (coefficients for sine term)</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : degvar(0:n) Degree variance</span>

<span class="sd">    Notes:</span>
<span class="sd">        .. math::</span>
<span class="sd">            degvar(n)=\sum(c(n,m)^2+s(n,m)^2) \qquad m=0,1,2,....,n \quad n=0,1,2, \dots, N</span>

<span class="sd">        where :math:`N` the maximum degree</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_degree_var</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span></div>


<div class="viewcode-block" id="j2j3"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.j2j3">[docs]</a><span class="k">def</span> <span class="nf">j2j3</span><span class="p">(</span><span class="n">zlat</span><span class="p">,</span> <span class="n">dlat</span><span class="p">,</span> <span class="n">dlon</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate j2 and j3 at special grid point</span>

<span class="sd">    Args:</span>
<span class="sd">        zlat (float): Co-latitude at grid center (unit: degree)</span>
<span class="sd">        dlat (float): Interval of latitude (or grid length in latitude direction) (unit: degree)</span>
<span class="sd">        dlon (float): Interval of longitude (or grid length in longitude direction) (unit: degree)</span>
<span class="sd">        hi (float): Height variation of mass---usually use equivalent water height (unit: meter)</span>
<span class="sd">        rho (float): Density of mass--usually water density (1000kg/m^3)  (unit: kg/m^3)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * dj2 (float) : J2 value</span>
<span class="sd">            * dj3 (float) : J3 value</span>

<span class="sd">    Notes:</span>
<span class="sd">        here J2=-C(2,0), and C(2,0) is not fully normalized spherical coefficient, C(2,0)=sqrt(5)*C(2,0)(normalized)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Dickey J O, et al., Recent Earth Oblateness variations: Unraveling climate and postglacial rebound effects,  Science, Vol. 298, p1975-1977, 2002.</span>

<span class="sd">        Please see supplement material of the above paper for the  Equation to calculate J2.</span>

<span class="sd">    Examples:</span>
<span class="sd">        todo</span>

<span class="sd">    See Also:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">j2j3</span><span class="p">(</span><span class="n">zlat</span><span class="p">,</span> <span class="n">dlat</span><span class="p">,</span> <span class="n">dlon</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span></div>


<div class="viewcode-block" id="eaam_xyz_j2j3"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.eaam_xyz_j2j3">[docs]</a><span class="k">def</span> <span class="nf">eaam_xyz_j2j3</span><span class="p">(</span><span class="n">ltrop</span><span class="p">,</span> <span class="n">slp</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Todo:</span>
<span class="sd">        todo</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_eaam_xyz_j2j3</span><span class="p">(</span><span class="n">ltrop</span><span class="p">,</span> <span class="n">slp</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="load_vert_def"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.load_vert_def">[docs]</a><span class="k">def</span> <span class="nf">load_vert_def</span><span class="p">():</span>
    <span class="k">return</span></div>


<div class="viewcode-block" id="load_vert_exp"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.load_vert_exp">[docs]</a><span class="k">def</span> <span class="nf">load_vert_exp</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get the radial elastic deformation of the Earth&#39;s surface only estimated from atmospheric surface pressure field globally by experiment method.</span>

<span class="sd">    Args:</span>
<span class="sd">        p (array) : p[nlon,nlat], atmospheric surface pressure field (sorted by latitude (90~-90) first, then sorted by longitude (0~360). e.g. the coordinate of SIGMA should be (0.5,89.5) (1.5, 89.5),....(359.5,89.5) (0.5, 88.5) (1.5, 88.5).......... (359.5, -89.5) for 1x1 P). Unit of  P is Pascal. (Note: in the ocean, P must be set to 0.0d0)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * u[nlon, nlat]: Radial elastic defomation of the Earth&#39;s surface calculated by using experimental method(unit: mm) (grid mean value) , see comment for details. (Note: only 80N~60S have the values, other areas are 0)</span>
<span class="sd">            * pbar(nlon, nlat): The average pressure for each grid center point (surrounding area of the point is about 2000km wide), unit: Pascal. (Note: only 80N~60S have the values, other areas are 0)</span>

<span class="sd">    Notes:</span>
<span class="sd">        :math:`u=-0.9*pbar-0.35(p-pbar)`, here :math:`pbar` is the average (surrounding area of the point is 2000km wide) pressure for the point, and  p is the grid point surface pressure. See reference for details. This result is only the experimental value, the more precise value can be get by using LOAD_VERT_DEF.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Rabbel, W., J. Zschau, Static deformations and gravity changes at the Earth&#39;s surface due to atmospheric loading, J Geophys., 56, 81-99,1985.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_load_vert_exp</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></div>


<div class="viewcode-block" id="love"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.love">[docs]</a><span class="k">def</span> <span class="nf">love</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="s1">&#39;wang&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Get load love number from 0 to n (n&lt;=MAX) by cubic spline interpolation method</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : Maximum order of load love. (if n&gt;MAX, then all h(MAX:n),l(MAX:n), and k(MAX:n) will be infinity value, i.e. values of :math:`h_{\infty}`, :math:`l_{\infty}` and :math:`k_{\infty}`)</span>
<span class="sd">        ch (string) : optional in [&#39;wang&#39;, &#39;farrell&#39;], for &#39;wang&#39;, MAX=13000, for &#39;farrell&#39;, MAX=10000</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * h (array): h(n), Load love number h</span>
<span class="sd">            * l (array): l(n), Load love number l</span>
<span class="sd">            * k (array): k(n), Load love number k</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] FARRELL W. E., Reviews of geophysics and space physics, 10,3,761-797, 1972. Table A2.</span>
<span class="sd">        .. [2] Wang Hansheng, etc. New evolve of load love number for SNREI Earth model, Chinese J. Geophys.,vol.36,supp.,182-189,1996 (in Chinese)</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_love</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="n">ch</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">k</span></div>


<div class="viewcode-block" id="cs2cs"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.cs2cs">[docs]</a><span class="k">def</span> <span class="nf">cs2cs</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="s1">&#39;g2h&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change geopotential spherical harmonic coefficients to equivalent water height spherical harmonic coefficients or vice versa</span>

<span class="sd">    Args:</span>
<span class="sd">        c (array) : c(0:n, 0:n) The spherical harmonic coefficients for geopotential (unit:m? corresponding to geoid height?) or equivalent water height (unit: m)</span>
<span class="sd">        s (array) : s(0:n, 0:n) The spherical harmonic coefficients for geopotential (unit:m? corresponding to geoid height?) or equivalent water height (unit: m)</span>
<span class="sd">        cha (string) : should be in [&#39;g2h&#39;, &#39;h2g&#39;], default g2h, which means change geopotential spherical harmonic coefficients to equivalent water height spherical harmonic coefficients, if cha=&#39;h2g&#39;, then convert the equivalent water height spherical harmonic coefficients to geopotential spherical harmonic coefficients</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * c (array)</span>
<span class="sd">            * s (array)</span>

<span class="sd">    Notes:</span>
<span class="sd">        here we get the spherical harmonic coefficient as expansion of:</span>

<span class="sd">            .. math::</span>
<span class="sd">                dh = \\sum\\sum\\left\\{ P_{lm}\\left(\\cos \\theta \\right) \\left[ C_{lm}\\cos(m \\phi) + S_{lm}\\sin(m \\phi) \\right ] \\right \\}</span>

<span class="sd">        which is different with surface density defined by Wahr, 1998. The difference is the factor earth semi-radius and water density.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Wahr J.,M. Molenaar, F. Bryan, Time variablity of the Earth&#39;s gravity field: Hydrological and oceanic effects and their possible detection using GRACE, J. Geophys. Res. Vol.103, No.b12, P30205-30229,1998.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;g2h&#39;</span><span class="p">,</span> <span class="s1">&#39;h2g&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cond</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cond</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_cs2cs</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="n">cha</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span></div>


<div class="viewcode-block" id="cs2vertical"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.cs2vertical">[docs]</a><span class="k">def</span> <span class="nf">cs2vertical</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">depart_lon</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">alat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">water_density</span><span class="o">=</span><span class="mi">1</span><span class="n">e3</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="s1">&#39;ce&#39;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_cs2vertical</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">depart_lon</span><span class="o">=</span><span class="n">depart_lon</span><span class="p">,</span> <span class="n">alat</span><span class="o">=</span><span class="n">alat</span><span class="p">,</span>
                                          <span class="n">water_density</span><span class="o">=</span><span class="n">water_density</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">)</span></div>


<div class="viewcode-block" id="var_reduction"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.var_reduction">[docs]</a><span class="k">def</span> <span class="nf">var_reduction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_correction</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_var_reduction</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_correction</span><span class="p">)</span></div>
    <span class="c1"># pass</span>


<div class="viewcode-block" id="depth2pressure"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.depth2pressure">[docs]</a><span class="k">def</span> <span class="nf">depth2pressure</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;convert ocean depth to pressure</span>

<span class="sd">    Args:</span>
<span class="sd">        depth (float) : ocean depth (unit: meter)</span>
<span class="sd">        lat (float) : latitude in degree unit (:math:`-90^{\\circ} - 90^{\\circ})</span>

<span class="sd">    Return:</span>
<span class="sd">        float: ocean Pressure (unit: Pa).</span>

<span class="sd">    Notes:</span>
<span class="sd">        This pressure is gauge pressure under 1 atmospheric pressure, which means pressure=0 at sea surface</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Saunders, &quot;Practical Conversion of Pressure to Depth&quot;, J. Phys. Oceanog., April 1981.</span>

<span class="sd">    Examples:</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_depth2pressure</span><span class="p">(</span><span class="n">depth</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span></div>


<div class="viewcode-block" id="pressure2depth"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.pressure2depth">[docs]</a><span class="k">def</span> <span class="nf">pressure2depth</span><span class="p">(</span><span class="n">pressure</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;convert ocean pressure to depth</span>

<span class="sd">    Args:</span>
<span class="sd">        pressure (float) : ocean pressure (unit: Pa).</span>
<span class="sd">        lat (float) : latitude in degree unit (:math:`-90^{\\circ} - 90^{\\circ})</span>

<span class="sd">    Return:</span>
<span class="sd">        float : ocean depth (unit: meter)</span>

<span class="sd">    Notes:</span>
<span class="sd">        This pressure is gauge pressure under 1 atmospheric pressure, which means pressure=0 at sea surface</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Saunders, &quot;Practical Conversion of Pressure to Depth&quot;, J. Phys. Oceanog., April 1981.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_pressure2depth</span><span class="p">(</span><span class="n">pressure</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span></div>


<div class="viewcode-block" id="dm2lod"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.dm2lod">[docs]</a><span class="k">def</span> <span class="nf">dm2lod</span><span class="p">(</span><span class="n">dm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate global mass change effect on the length of day (LOD) change</span>

<span class="sd">    Arg:</span>
<span class="sd">        dm (float) : gloabl mass change (unit: kg)</span>

<span class="sd">    Return:</span>
<span class="sd">        float : global mass balance effect on LOD change (unit: ms)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Yan H., and B. Chao, Global mass balance effect on Earth&#39;s rotation rate, Geophys. Res. Lett., 2010</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_dm2lod</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span></div>


<div class="viewcode-block" id="fan_filter"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.fan_filter">[docs]</a><span class="k">def</span> <span class="nf">fan_filter</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">mmax</span><span class="p">,</span> <span class="n">r_lon</span><span class="p">,</span> <span class="n">r_lat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get Gaussian Fan filtering weight function in frequency domain which is used to filter spherical harmonic coefficients</span>

<span class="sd">    Args:</span>
<span class="sd">        nmax (int): Maximum degree number of Gaussian filtering weight function</span>
<span class="sd">        mmax (int): Maximum order number of Gaussian filtering weight function (mmax&lt;=nmax. If mmax&lt;nmax, then all w(i,j)==0.0 for j&gt;mmax)</span>
<span class="sd">        r_lon (float): r_lon is the filter average radius in longitude direction (unit: meter), which is the distance on the Earth&#39;s surface at which w has dropped to 1/2 it value at alpha=0 (the distance on the Earth&#39;s surface = Earth_R*alpha).</span>
<span class="sd">        r_lat (float): r_lat is the filter average radius in latitude direction (unit: meter).</span>

<span class="sd">    Returns:</span>
<span class="sd">        ndarray : w[nmax+1, nmax+1], Gaussian filtering weight function in frequency domain which is used to filter spherical harmonic coefficients</span>

<span class="sd">    Notes:</span>
<span class="sd">        Fan filter is a expansion of subroutine :func:`gauss_jekeli_fre`, which is the product of two :func:`gauss_jekeli_fre` weight in longitude and latitude direction.</span>

<span class="sd">        Here we use the equations of C. Jekeli. So when you use the equation defined by Wahr J. (1998), note the difference for factor 2*pi. E.G., in Wahr J. (1998), eq.(30) now can omit the factor 2*pi, you can get the same results.</span>

<span class="sd">        In the frequency domain, the Gaussian filtering weight function can be computed with recursion relations (see Algorithm in :func:`gauss_jekeli` for definition of a):</span>

<span class="sd">            .. math::</span>
<span class="sd">                W_0 &amp; = 1 \\\\</span>
<span class="sd">                W_1 &amp; = \\frac{1 + e^{-2a}}{1 - e^{-2a}} - \\frac{1}{a} \\\\</span>
<span class="sd">                W_{n+1} &amp; = -\\frac{2n + 1}{a}W_{n} + W_{n-1}</span>

<span class="sd">        Now :math:`W_{ij}` can be multiplied to the spherical harmonic coefficients calculated from :func:`fun_exp_fft`, and then use :func:`func_sum_fft` to get the Gaussian filtering weighted spherical function value in space domain.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Zhang, Z., B.F. Chao, Y. Lu, and H.Hsu(2009), An effective filtering for GRACE time-variable gravity: Fan filter, Geophys. Res. Lett., 36,L17311, doi:10.1029/2009GL039459.</span>
<span class="sd">        .. [2] Jekeli, C., Alternative methods to smooth the Earth&#39;s gravity field, Rep.327, Dep. of Geod. Sci. and Surv., Ohio State Univ., Columbus,1981.</span>
<span class="sd">        .. [3] Wahr J.,M. Molenaar, F. Bryan, Time variablity of the Earth&#39;s gravity field: Hydrological and oceanic effects and their possible detection using GRACE, J. Geophys. Res. Vol.103, No.b12, P30205-30229,1998.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_fan_filter</span><span class="p">(</span><span class="n">nmax</span><span class="p">,</span> <span class="n">mmax</span><span class="p">,</span> <span class="n">r_lon</span><span class="p">,</span> <span class="n">r_lat</span><span class="p">)</span></div>


<div class="viewcode-block" id="green"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.green">[docs]</a><span class="k">def</span> <span class="nf">green</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">n_max_love</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="s2">&quot;vd&quot;</span><span class="p">,</span> <span class="n">cha_norm</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the GREEN functions for surface vertical/horizontal displacement, geoid, gravity change, tilt change, free air gravity, potential, and stress.</span>

<span class="sd">    Args:</span>
<span class="sd">        theta (array) : theta[n], Radial distance away the observed station</span>
<span class="sd">        n_max_love (int) : The maximum order of Love number to be used to calculate Green function. If n_max_love&gt;13000, then there is an interpolation be used to get the value of that Love number. Note: the Love number values are in a file named love.prem.13000.dat, which should be located in c:\wfl\cvf\lib directory, to use WFL_GREEN, you must copy this file in your working dirctory.</span>
<span class="sd">        cha (string) : Character to index which Green function can be returned to green_value(n). cha=&#39;vd&#39; or &#39;VD&#39; , cha=&#39;hd&#39; or &#39;HD&#39;, cha=&#39;gc&#39; or &#39;GC&#39;, cha=&#39;dg&#39; or &#39;DG&#39;, cha=&#39;ig&#39; or &#39;IG&#39;, cha=&#39;dig&#39; or &#39;DIG&#39;, cha=&#39;tc&#39; or &#39;TC&#39;, cha=&#39;fag&#39; or &#39;FAG&#39;, cha=&#39;pc&#39; or &#39;PC&#39;, cha=&#39;sc&#39; or &#39;SC&#39; for Green function of surface Vertical Displacement (VD), surface Horizontal Displacement (HD), Geoid Change (GC), Direct effect of Gravity (DG), Indirect effect of Gravity (IG), Direct + Indirect effect of Gravity (DIG), Tilt Change (TC), Free Air Gravity (FAG), Potential Change (PC), and Stress Change (SC). For more details, please see Comments|Reference.</span>
<span class="sd">        cha_norm (bool): If True, then the output Green functions will be normalized by different factors. See Algorithm for more details.</span>

<span class="sd">    Return:</span>
<span class="sd">        array : green_value[n]</span>

<span class="sd">    Notes:</span>
<span class="sd">        When cha_norm is True, then the green function is normalized by below factor:</span>
<span class="sd">            *1011*Earth_radius*theta (theta is in radian unit) for &#39;vd&#39;, &#39;hd&#39; and &#39;gc&#39;;</span>
<span class="sd">            *1017*Earth_radius*theta (theta is in radian unit) for &#39;dg&#39;, &#39;ig&#39;, &#39;dig&#39;, and &#39;fag&#39;;</span>
<span class="sd">            *1011*(Earth_radius*theta)2 (theta is in radian unit) for &#39;tc&#39; and &#39;sc&#39;;</span>
<span class="sd">            *108*Earth_radius*theta (theta is in radian unit) for &#39;pc&#39;.</span>
<span class="sd">        All the unit is in kg, m, s, etc.</span>
<span class="sd">        For &#39;vd&#39; and &#39;hd&#39;, the equation used outside the summation is Earth_radius/Earth_mass</span>
<span class="sd">        For &#39;dg&#39;,&#39;ig&#39;,and &#39;dig&#39;, the equation used outside the summation is g/Earth_mass.</span>
<span class="sd">        Other green functions are not used for me, so do it yourself.</span>
<span class="sd">        This subroutine is modified from a Fortran77 program provided by Dr. Wang Hansheng.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">cha_norm</span> <span class="o">=</span> <span class="s1">&#39;norm&#39;</span> <span class="k">if</span> <span class="n">cha_norm</span> <span class="k">else</span> <span class="s1">&#39;unnorm&#39;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;vd&#39;</span><span class="p">,</span> <span class="s1">&#39;hd&#39;</span><span class="p">,</span> <span class="s1">&#39;gc&#39;</span><span class="p">,</span> <span class="s1">&#39;dg&#39;</span><span class="p">,</span> <span class="s1">&#39;ig&#39;</span><span class="p">,</span> <span class="s1">&#39;dig&#39;</span><span class="p">,</span> <span class="s1">&#39;tc&#39;</span><span class="p">,</span> <span class="s1">&#39;fag&#39;</span><span class="p">,</span> <span class="s1">&#39;pc&#39;</span><span class="p">,</span> <span class="s1">&#39;sc&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cha should be in [</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conds</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_green</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">n_max_love</span><span class="p">,</span> <span class="n">cha</span><span class="p">,</span> <span class="n">cha_norm</span><span class="o">=</span><span class="n">cha_norm</span><span class="p">)</span></div>


<div class="viewcode-block" id="green_func_theta"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.green_func_theta">[docs]</a><span class="k">def</span> <span class="nf">green_func_theta</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Generate angle distance (0.1d-4 ~ 179.5) with smaller step to larger step. The output will be used in Green functions calculation.</span>

<span class="sd">    Arg:</span>
<span class="sd">        n (int) : # of output (n should be 452, if you want to get all the values)</span>

<span class="sd">    Return:</span>
<span class="sd">        array : theta[n] angle distance from 0.00001 to 179.5 (unit: degree)</span>

<span class="sd">    Notes:</span>
<span class="sd">        if input n&lt;=452, the theta[n] will be output; if input n&gt;452, theta[453:]==0.0</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_green_func_theta</span><span class="p">(</span><span class="n">n</span><span class="p">)</span></div>


<div class="viewcode-block" id="grace_destripe"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.grace_destripe">[docs]</a><span class="k">def</span> <span class="nf">grace_destripe</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">fit_order</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="potential_temperture_to_situ"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.potential_temperture_to_situ">[docs]</a><span class="k">def</span> <span class="nf">potential_temperture_to_situ</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">reference_pressure</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;convert potential temperature (theta) to in situ temperature (t) in ocean.</span>

<span class="sd">    Args:</span>
<span class="sd">        s (float) : salinity (unit: psu)</span>
<span class="sd">        theta (float) : potential temperature (unit: deg Celsius) at pressure level pr0</span>
<span class="sd">        pressure (float) : in situ pressure level (unit: Pascal)</span>
<span class="sd">        reference_pressure (float) : reference pressure level for potential temperature (unit: Pascal). If not presented, pr0==0, which means the sea surface.</span>

<span class="sd">    Return:</span>
<span class="sd">        float : t, in situ temperature (unit: deg Celsius) at pressure level reference_pressure.</span>

<span class="sd">    Notes:</span>
<span class="sd">        Potential temperature has been defined classically as the temperature an element of seawater would have if raised adiabatically with no change of salinity to atmospheric pressure (or sea surface with reference_pressure==0). More generally, the potential temperature can be defined as the temperature resulting from an adiabatic displacement to a reference pressure pr that may be greater or less than the initial pressure p. The potential temperature :math:`\\theta` can be computed from the adiabatic lapse rate :math:`\\Gamma`,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\theta(s, t, p, p_r) = t + \\int_{p}^{p_r} \\Gamma(s, t^{&#39;}, p)dp^{&#39;}</span>

<span class="sd">        by integration along an adiabat, i.e. :math:`\\partial t^{&#39;}/ \\partial p^{&#39;} = \\Gamma^{&#39;}`. The potential temperature can be evaluated by using an empirical formula or by numerical integration of the defining equation.</span>

<span class="sd">        Here, the potential temperature :math:`\\theta(s, t, p, p_r)` at reference pressure pr can be computed with sufficient precision using a 4th order Runge-Kutta integration algorithm (Fofonoff, 1977).</span>

<span class="sd">        The in situ temperature can be calculated by the inversion of the above process of potential temperature calculation.</span>

<span class="sd">        For the atmosphere, the relation between potential temperature and in situ temperature is very simple, and can be acquired by,</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\theta = T(p_r / p)^{0.286}</span>

<span class="sd">        where :math:`p_r` is reference pressure level (usually 1000mb), and p is in situ pressure level, and :math:`T` is in situ temperature. Note, here, the unit of :math:`\theta` and :math:`T` is Kelvin, not deg Celsius.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Bryden, 1973, polynomial for adiabatic lapse rate ! and runge-kutta 4-th order intergration algorithm.</span>
<span class="sd">        .. [2] Bryden H,1973, deep-sea res., 20, 401-408</span>
<span class="sd">        .. [3] Rofonoff, N., 1977, Deep-sea res., 24, 489-491</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_in_situ_temp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">pr0</span><span class="o">=</span><span class="n">reference_pressure</span><span class="p">)</span></div>


<div class="viewcode-block" id="situ_temperatrue_to_potential"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.situ_temperatrue_to_potential">[docs]</a><span class="k">def</span> <span class="nf">situ_temperatrue_to_potential</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">reference_pressure</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        s (float) : salinity (unit: psu)</span>
<span class="sd">        t (float) : in situ temperature (unit: deg Celsius) at pressure level reference_pressure.</span>
<span class="sd">        pressure (float) : in situ pressure level (unit: Pascal)</span>
<span class="sd">        reference_pressure (float) : reference pressure level for potential temperature (unit: Pascal). If not presented, pr0==0, which means the sea surface.</span>

<span class="sd">    Return:</span>
<span class="sd">        float : potential temperature (unit: deg Celsius) at pressure level pr0</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`potential_temperture_to_situ`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_potential_temp</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">pressure</span><span class="p">,</span> <span class="n">pr0</span><span class="o">=</span><span class="n">reference_pressure</span><span class="p">)</span></div>


<div class="viewcode-block" id="j2j4j6"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.j2j4j6">[docs]</a><span class="k">def</span> <span class="nf">j2j4j6</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">gm</span><span class="p">,</span> <span class="n">omiga</span><span class="p">,</span> <span class="n">inv_f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate J2, J4 and J6 from Earth referenced ellipsoid parameters</span>

<span class="sd">    Args:</span>
<span class="sd">        r (float) : Earth&#39;s equatorial radius (in meter), if input r=0.d0, then substitutes it with value of 6378137m.</span>
<span class="sd">        gm (float) :Geocentric gravitational constant (in m**3/s**2), if input gm=0.0d0, then substitutes it with value of 3.986005e+14 m**3/s**2.</span>
<span class="sd">        omiga (float) :Earth&#39;s angular velocity (in Rad/s), if input omig=0.d0, then substitutes it with value of 7.292115D-5 rad/s.</span>
<span class="sd">        inv_f (float) :inverse of Earth&#39;s flattening (==1/f), if input inv_f=0.d0, then substitutes it with value of 298.257222101.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * j (array) : j(1:3) corresponding with J2, J4 and J6, respectively.</span>
<span class="sd">            * c(array) : c(1:3) corresponding with fully normalized zonal spherical harmonic coefficients C20, C40, and C60, respectively.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The default input Earth&#39;s ellipsoid parameters are adopted from IERS 2003 conventions, see &quot;Table 1.2: Parameters of the Geodetic Reference System GRS80&quot; for details.</span>

<span class="sd">        The output values are often used to calculate gravity anomalies from spherical harmonic coefficients geoid modle such as GGM03C, GGM03S, EGM96, and so on.</span>

<span class="sd">    reference:</span>
<span class="sd">       .. [1] Rapp R. H., A Fortran program for the computation of gravimetric quantities from high degree spherical harmonic expansions, OSU Reports No. 334, 1982.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_j2j4j6</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">gm</span><span class="p">,</span> <span class="n">omiga</span><span class="p">,</span> <span class="n">inv_f</span><span class="p">)</span></div>


<div class="viewcode-block" id="lod2torque"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.lod2torque">[docs]</a><span class="k">def</span> <span class="nf">lod2torque</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">lod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change LOD (length of day)  to torque (z axis)</span>

<span class="sd">    Args:</span>
<span class="sd">        dt (float) : time interval step of input array</span>
<span class="sd">        lod (array) : lod[n], LOD change (unit: ms)</span>

<span class="sd">    Returns:</span>
<span class="sd">        array: torque_lod[n], The corresponding torque in z axis, unit: Hadley, see :func:`torque` for details</span>

<span class="sd">    Notes:</span>
<span class="sd">        torque_lod(1),torque_lod(n) are interpolated from torque_lod(2) and torque_lod(n-1), respectively.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_lod2torque</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">lod</span><span class="p">)</span></div>


<div class="viewcode-block" id="mountain_torque"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.mountain_torque">[docs]</a><span class="k">def</span> <span class="nf">mountain_torque</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">hm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Using torque method to calculate mountain torques from atmosphere/water to solid Earth</span>

<span class="sd">    Args:</span>
<span class="sd">        sp : (lon,lat), surface pressure (unit: Pa) or water height (unit: cm*100 or 0.1mm) (centered grid data) (north-&gt;south direction (N-&gt;S), for 1*1 grid, the coordinate is like (0.5,89.5),(1.5,89.5),(2.5,89.5),.....(359.5,89.5),(0.5,88.5),(1.5,88.5)....)</span>
<span class="sd">        hm : (lon,lat), topography/orography data (unit: m) (centered grid data) (N-&gt;S, for 1*1 grid, the coordinate is like (0.5, 89.5), (1.5, 89.5),...(359.5, 89.5), (0.5, 88.5), (1.5, 88.5)...)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * te : (lon,lat), complex output (x+iy), ellipsoidal torque for IB hypothesis (centered grid data, N-&gt;S) (unit:Hadley, 1HU=10**18kg.m.m/s/s=N.m)</span>
<span class="sd">            * ten : (lon,lat), complex output (x+iy), ellipsoidal torque for NIB hypothesis (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tm_dp : (lon,lat),  complex output (x+iy), mountain torque for IB hypothesis using pressure gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tmn_dp : (lon,lat), complex output (x+iy), mountain torque for NIB hypothesis using pressure gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tm_dh : (lon,lat), complex output (x+iy), mountain torque for IB hypothesis using topography gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tmn_dh : (lon,lat), complex output (x+iy), mountain torque for NIB hypothesis using topography gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tm3_dp : (lon,lat), z component, mountain torque for IB hypothesis using pressure gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tm3n_dp : (lon,lat), z component, mountain torque for NIB hypothesis using pressure gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tm3_dh : (lon,lat), z component, mountain torque for NIB hypothesis using pressure gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * tm3n_dh : (lon,lat), z component, mountain torque for NIB hypothesis using topography gradient method (centered grid data, N-&gt;S) (unit:Hadley)</span>

<span class="sd">    Notes:</span>
<span class="sd">        This is the subset of subroutine :func:`torque`, but with centered data input only for surface pressure/water data.</span>
<span class="sd">        For water height data such as land-water, usually use non-IB results. For surface pressure data, usually use IB results.</span>
<span class="sd">        For the water data input, if you have water data with cm unit, then you should multiply the water data by 100 as the input SP parameter.</span>

<span class="sd">        The mountain torque equations in the three Egger B. J. paper are wrong. The mountain torque equation of Schindelegger M. paper is correct</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Egger B. J. and K. P. Hoinka, Equatorial components of global atmospheric angular momentum: covariance functions, Q. J. R. Meteorol. Soc., Vol. 128, p1137-1157, 2002.</span>
<span class="sd">        .. [2] Egger B. J. and K. P. Hoinka, Mountain torques and the equatorial components of global angular momentum, J. Atmos. Sci., p2319-2331, 2000.</span>
<span class="sd">        .. [3] Egger B. J., K. Weickmann, and K. P. Hoinka, Angular momentum in the global atmospheric circulation, Rev. Geophys., Vol. 45, RG4007, 2007.</span>
<span class="sd">        .. [4] Schindelegger M., J. Bohm and D. Salstein, Seasonal and intraseasonal polar motion variability as deduced from atmospheric torques, J. Geod. Geoinfor., Vol. 1, P89-95, 2012</span>
<span class="sd">        .. [5] Schindelegger M., D. Salsteim and J. Bohm, Recent estimates of Earth-atmosphere interaction torques and their use in studying polar motion variability, J. Geophys. Res., Vol. 118, p4586-4598, 2013.</span>
<span class="sd">        .. [6] Feldstein S. B., The dynamics of atmospherically driven intraseasonal polar motion, J. Atmos. Sci., Vol. 65, P2290-2307,2008.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_mountain_torque</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">hm</span><span class="p">)</span></div>


<div class="viewcode-block" id="prem"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.prem">[docs]</a><span class="k">def</span> <span class="nf">prem</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">parameter</span><span class="o">=</span><span class="s1">&#39;density&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Acquiring PREM parameters (depth, density, mass, gravity acceleration, pressure, and moment of inertia)</span>

<span class="sd">    Args:</span>
<span class="sd">        n (int) : The layers of PREM, n must equal 76 here. (n==76)</span>
<span class="sd">        parameter (string) : default density</span>
<span class="sd">            * &#39;mass&#39;, then  prem_out(:,2) output integral of mass of Earth from Earth&#39;s center to surface (unit: kg)</span>
<span class="sd">            * &#39;gravity&#39;, then prem_out(:,2) output gravity acceleration of Earth in each layer  (unit:m/s**2)</span>
<span class="sd">            * &#39;pressure&#39;, then prem_out(:,2) output pressures of Earth in each layer (unit: Pa)</span>
<span class="sd">            * &#39;inertial&#39;, then  prem_out(:,2) output integral of moment of inertia of Earth from Earth&#39;s center to surface (unit: kg.m**2)</span>
<span class="sd">            * &#39;density&#39;, then  prem_out(:,2) output density of Earth in each layer (unit: kg/m**3)</span>

<span class="sd">    Returns:</span>
<span class="sd">        2darray : prem_out[n, 2], prem_out[:,0] is the depth of Earth (unit: km), prem_out[:,1] is the other output parameters defined by &quot;prem_parameter&quot; optional input parameter.</span>

<span class="sd">    Notes:</span>
<span class="sd">        PREM: The isotropic model parameters in the table below are taken from:</span>
<span class="sd">            Dziewonski A.M., Anderson D.L.(1981): Preliminary reference Earth model. Phys. Earth planet. Inter., 25, 297.</span>
<span class="sd">        Some values, specified in the table II of the paper, which can likely be accurately fitted by cubic splines are left out. Between the given points within each complex block, the parameters are interpolated by means of natural cubic splines. If only one value of a material parameter is specified per a layer, the parameter is assumed constant within the layer. In the input data for complete ray tracing, the values of density are specified only at the interfaces because elsewhere they have no influence upon the high-frequency asymptotics.</span>

<span class="sd">&quot;&quot;&quot;</span></div>


<div class="viewcode-block" id="rm_sp_from_sg"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.rm_sp_from_sg">[docs]</a><span class="k">def</span> <span class="nf">rm_sp_from_sg</span><span class="p">(</span><span class="n">fre</span><span class="p">,</span> <span class="n">fre_idx</span><span class="p">,</span> <span class="n">spec_sp</span><span class="p">,</span> <span class="n">spec_sg</span><span class="p">,</span> <span class="n">m_order</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Removing surface pressure (solar heating tide) form observed super-conductive gravity</span>

<span class="sd">    Args:</span>
<span class="sd">        fre (array) : frequency index of power spectrum</span>
<span class="sd">        fre_idx (array) : fre_idx[2], frequency index for determination of line equation, then using this line equation to do linear interpolation to get all frequency correction coefficients. Using this coefficients to remove solar heating tide from SG power spectrum.</span>
<span class="sd">        spec_sp (array) : Power spectrum of surface pressure at the station.</span>
<span class="sd">        spec_sg (array) : Power spectrum of the super-conductive gravity at the station.</span>
<span class="sd">        m_order (int) : If larger than 0, then use it as the order of polynomial to fit the back ground noise spectrum. If equal to 0, then use BIC criterion to get the best fit order of polynomial fit, and using this best fit order to fit the back ground noise spectrum.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : SG power spectrum removed solar heating tide.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_rm_sp_from_sg</span><span class="p">(</span><span class="n">fre</span><span class="p">,</span> <span class="n">fre_idx</span><span class="p">,</span> <span class="n">spec_sp</span><span class="p">,</span> <span class="n">spec_sg</span><span class="p">,</span> <span class="n">m_order</span><span class="o">=</span><span class="n">m_order</span><span class="p">)</span></div>


<div class="viewcode-block" id="search_resonance"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.search_resonance">[docs]</a><span class="k">def</span> <span class="nf">search_resonance</span><span class="p">(</span><span class="n">fre</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">n_window</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Search resonance response from Super-conduction Gravity (SG) power spectrum</span>

<span class="sd">    Args:</span>
<span class="sd">        fre (array) : Frequency index for the input power spectrum</span>
<span class="sd">        spec (array) : Power spectrum to be analysised</span>
<span class="sd">        n_window (int) : The parameter &quot;n_window&quot; is a very important parameter when computing the resonance parameter &quot;resonance_parameter&quot;. You can change it to different value to see the different results. Typically, n_window should small (maybe around 11, both 5 points from the resonance point) for a true resonance.</span>
<span class="sd">        q (float) : Quality factor, typical value of 100~400.</span>

<span class="sd">    Return:</span>
<span class="sd">        array : Resonance parameter (big value means there is resonance)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Smylie D. E., J. Hinderer, B. Richter, and B. Ducarme, The porduct spectra of gravity and barometric pressure in Europe, Physics of the Earth and Planetary Interiors, 80, 135-157, 1993. eq. (50-53)</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_search_resonance</span><span class="p">(</span><span class="n">fre</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">n_window</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span></div>


<div class="viewcode-block" id="sg_multistation"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.sg_multistation">[docs]</a><span class="k">def</span> <span class="nf">sg_multistation</span><span class="p">(</span><span class="n">alon</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get translational modes (Slichter modes) from multi-station Superconductive Gravimeter (SG) residuals</span>

<span class="sd">    Args:</span>
<span class="sd">        alon (array) : alon[n], Longitude coordinates of the corresponding SG stations</span>
<span class="sd">        alat (array) : alat[n], Latitude coordinates of the corresponding SG stations. Note, alon(i), and alat(i) should be the ith station&#39;s coordinates.</span>
<span class="sd">        sg (2darray): sg[n, ns], SG residuals time series (n length, n &gt;= 3) at ns stations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : Signals of 3 translational modes from input SG residuals time series (length n, stations ns). sg_out[:,0] for prograde equatorial components, sg_out[:,1] for axial components, and sg_out[:,2] for retrograde equatorial components.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Courtier, N., et al., Global superconducting gravimeter observations and the search for the translational modes of inner core, Physics of the Earth and Planetary Interiors (PEPI), 117, P3-20, 2000. Eq. (5), (7)</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_sg_multistation</span><span class="p">(</span><span class="n">alon</span><span class="p">,</span> <span class="n">alt</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span></div>


<div class="viewcode-block" id="soiltemp"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.soiltemp">[docs]</a><span class="k">def</span> <span class="nf">soiltemp</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">average_t</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">year_begin</span><span class="p">,</span> <span class="n">nday</span><span class="p">,</span> <span class="n">td</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;day&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get soil temperature at given depth from surface temperature</span>

<span class="sd">    Args:</span>
<span class="sd">        amp (float): Amplitude of surface temperature for given period (amp unit: degree)</span>
<span class="sd">        period (float) : period of surface temperature, period&gt;2day. (unit: day or hour, see optional parameter unit for details)</span>
<span class="sd">        phase (float) : initial phase of the surface temperature (unit: degree). The amp and phase can be accquired from surface temperature time series by using subroutine :func:`harmonic`. The phase definition is the same as in :func:`harmonic`.</span>
<span class="sd">        average_t (float) : Multiyear average temperature of surface temperature (unit: degree)</span>
<span class="sd">        depth (float) : the depth of soil, depth&gt;0 (unit: mm)</span>
<span class="sd">        year_begin (int) : the begin year for output, the time index of first output is Jan 1, year_begin.</span>
<span class="sd">        nday (int) : unit of input optional parameter unit (days or hours) from the firs time index</span>
<span class="sd">        TD (float) : Thermal Diffusivity. If not presented, the default value is TD=1mm**2/s   (unit: mm**2/s)</span>
<span class="sd">        unit (string) : Unit of output time index, default is &quot;day&quot;. If not presented or presented and unit=&#39;day&#39; (case-insensitive), then the unit of output time index interval is day. If presented and unit=&#39;hour&#39; (case-insensitive), then output time index interval is hour. For annual, semi-annual period, and period&gt;2days, you can use unit &#39;day&#39;. For diurnal, semi-diurnal and period&gt;2 hours, you can use unit &#39;hour&#39;. The output year and MJD index is in unit year and day with suitable decimals and intervals in day or hour.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : soil_t(nday,3) soil_t[:,0] time index (year); soil_t[:,1] time index (MJD); soil_t[:,2] soil temperature at given depth (unit: degree)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Yan H., W. Chen, Y. Zhu, G. Liu, and M. Zhong, thermal expansion effect on GPS height change, 2009.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_soiltemp</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">average_t</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">year_begin</span><span class="p">,</span> <span class="n">nday</span><span class="p">,</span> <span class="n">td</span><span class="o">=</span><span class="n">td</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span></div>


<div class="viewcode-block" id="solar_heat_tide"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.solar_heat_tide">[docs]</a><span class="k">def</span> <span class="nf">solar_heat_tide</span><span class="p">(</span><span class="n">fre</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">index_fre</span><span class="p">,</span> <span class="n">n_window</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Remove solar heating tides effects from Super-conduction Gravity (SG) power spectrum</span>

<span class="sd">    Args:</span>
<span class="sd">        fre (array) : fre[n], Frequency index for the input power spectrum</span>
<span class="sd">        spec(array) : spec[n], Power spectrum to be analysised</span>
<span class="sd">        index_fre (array) : index_fre[m], Integer number position of the above solar heating tides frequency in fre(n), e.g. index_fre(1)=83, means fre(83)=1/24 cycle/hr. Note, index_fre(1)&gt;3*n_window/2 , index_fre(m) &lt; n-3*n_window/2 . Also note, index_fre(:) must be monotonic.</span>
<span class="sd">        n_window (int) : Window width (must be odd) for removing the solar heating tides effect. e.g. n_window=25, means there are 25/2 points on both side of fre( index_fre(1) ) will be removed, respectively. Note, n_window &lt; n</span>
<span class="sd">        Q (float) : Quality factor, typical value of 100~400.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : spec_out[n], Power spectrum which the solar heat tides had been removed from the input spec.</span>

<span class="sd">    Notes:</span>
<span class="sd">        The effects of removing solar heat tides is limited. This is NOT the best method to remove solar heat tides.</span>

<span class="sd">    Reference:</span>
<span class="sd">        ..[1] Smylie D. E., J. Hinderer, B. Richter, and B. Ducarme, The porduct spectra of gravity and barometric pressure in Europe, Physics of the Earth and Planetary Interiors, 80, 135-157, 1993. eq. (47-49)</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_solar_heat_tide</span><span class="p">(</span><span class="n">fre</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="n">index_fre</span><span class="p">,</span> <span class="n">n_window</span><span class="p">,</span> <span class="n">q</span><span class="p">)</span></div>


<div class="viewcode-block" id="stress_torque"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.stress_torque">[docs]</a><span class="k">def</span> <span class="nf">stress_torque</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="n">nts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Using torque method to calculate stress (both friction and gravity wave) torques from atmosphere to solid Earth</span>

<span class="sd">    Args:</span>
<span class="sd">        ETS (array) : ETS[lon, lat] : eastward turbulent (or gravity wave) surface stress  (unit: N/m2) (lattice grid data) (N-&gt;S) . If unit is (N m-2 s), then divide the data with the time step of the data. For example, if daily data were used, then divide 3600s*24h=86400s to get unit of N/m2 . Other input parameters is the same as here.</span>
<span class="sd">        NTS (array) : NTS[lon, lat] : northward turbulent (or gravity wave) surface stress (unit: N/m2) (lattice grid data) (N-&gt;S)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple :</span>
<span class="sd">            * TF[lon, lat]: complex output (x+iy), friction (or gravity wave) torque (centered grid data, N-&gt;S) (unit:Hadley)</span>
<span class="sd">            * TF3[lon, lat]: z component, friction (or gravity wave) torque (centered grid data, N-&gt;S) (unit:Hadley)</span>

<span class="sd">    Notes:</span>
<span class="sd">        This is the subset of subroutine :func:`torque`, but with centered data input only for stress data.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Egger B. J. and K. P. Hoinka, Equatorial components of global atmospheric angular momentum: covariance functions, Q. J. R. Meteorol. Soc., Vol. 128, p1137-1157, 2002.</span>
<span class="sd">        .. [2] Egger B. J. and K. P. Hoinka, Mountain torques and the equatorial components of global angular momentum, J. Atmos. Sci., p2319-2331, 2000.</span>
<span class="sd">        .. [3] Egger B. J., K. Weickmann, and K. P. Hoinka, Angular momentum in the global atmospheric circulation, Rev. Geophys., Vol. 45, RG4007, 2007.</span>
<span class="sd">        .. [4] Schindelegger M., J. Bohm and D. Salstein, Seasonal and intraseasonal polar motion variability as deduced from atmospheric torques, J. Geod. Geoinfor., Vol. 1, P89-95, 2012</span>
<span class="sd">        .. [5] Schindelegger M., D. Salsteim and J. Bohm, Recent estimates of Earth-atmosphere interaction torques and their use in studying polar motion variability, J. Geophys. Res., Vol. 118, p4586-4598, 2013.</span>
<span class="sd">        .. [6] Feldstein S. B., The dynamics of atmospherically driven intraseasonal polar motion, J. Atmos. Sci., Vol. 65, P2290-2307,2008.</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`mountain_torque`, :func:`torque`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_stress_torque</span><span class="p">(</span><span class="n">ets</span><span class="p">,</span> <span class="n">nts</span><span class="p">)</span></div>


<div class="viewcode-block" id="thermal_vertical_deformation"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.thermal_vertical_deformation">[docs]</a><span class="k">def</span> <span class="nf">thermal_vertical_deformation</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">year_begin</span><span class="p">,</span> <span class="n">nday</span><span class="p">,</span> <span class="n">pr</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span> <span class="n">ltec</span><span class="o">=</span><span class="mi">12</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span> <span class="n">td</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;day&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Using a half-space head conduction model to calculate the vertical change of bed rock</span>

<span class="sd">    Args:</span>
<span class="sd">        amp (float) : Amplitude of surface temperature for given period (amp unit: degree)</span>
<span class="sd">        period (float) : period of surface temperature, period&gt;2day. (unit: day or hour)</span>
<span class="sd">        phase (float) : initial phase of the surface temperature (unit: degree). The amp and phase can be accquired from surface temperature time series by usingsubroutine HARMONIC. The phase definition is the same as in HARMONIC.</span>
<span class="sd">        year_begin (int) :the begin year for output, the time index of first output is Jan 1, year_begin.</span>
<span class="sd">        nday (int) : unit of input optional parameter unit (days or hours) from the firs time index</span>
<span class="sd">        pr (float) : Poisson&#39;s Ratio. If not presented, the default value is PR=0.25</span>
<span class="sd">        ltec (float) : Linear Thermal Expansion Coefficient. If not presented, the default value is LTEC=12.D-6  ( or 12*10-6).  (unit: 1/degree)</span>
<span class="sd">        td (float) : Thermal Diffusivity. If not presented, the default value is TD=1mm**2/s   (unit: mm**2/s)</span>
<span class="sd">        unit (string) : Unit of output time index, default is &quot;day&quot;. If not presented or presented and unit=&#39;day&#39; (case-insensitive), then the unit of output time index interval is day. If presented and unit=&#39;hour&#39; (case-insensitive), then output time index interval is hour. For annual, semi-annual period, and period&gt;2days, you can use unit &#39;day&#39;. For diurnal, semi-diurnal and period&gt;2 hours, you can use unit &#39;hour&#39;. The output year and MJD index is in unit year and day with suitable decimals and intervals in day or hour.</span>

<span class="sd">    Returns:</span>
<span class="sd">        array : dh(nday,3), dh[:,0] time index (year); dh[:,1] time index (MJD); dh[:,2] vertical change of bed rock induced by thermal expansion (unit: mm)</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] Yan H., W. Chen, Y. Zhu, G. Liu, and M. Zhong, thermal expansion effect on GPS height change, submitted to .., 2009.</span>
<span class="sd">        .. [2] Dong D., P. Fang, Y. Bock, M. Cheng and S. Miyazaki, 2002, Anatomy of apparent seasonal variations from GPS-derived site position time series, J Geophys Res, Vol. 107, No. B4, 2075, doi:10.1029/2001JB000573</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;day&#39;</span><span class="p">,</span> <span class="s1">&#39;hour&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unit should be in [</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conds</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_thermalv</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">year_begin</span><span class="p">,</span> <span class="n">nday</span><span class="p">,</span> <span class="n">pr</span><span class="o">=</span><span class="n">pr</span><span class="p">,</span> <span class="n">ltec</span><span class="o">=</span><span class="n">ltec</span><span class="p">,</span> <span class="n">td</span><span class="o">=</span><span class="n">td</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">td</span><span class="p">)</span></div>


<div class="viewcode-block" id="torque"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.torque">[docs]</a><span class="k">def</span> <span class="nf">torque</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">ets</span><span class="p">,</span> <span class="n">nts</span><span class="p">,</span> <span class="n">egws</span><span class="p">,</span> <span class="n">ngws</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Using torque method to calculate torques from atmosphere to solid Earth</span>

<span class="sd">    Args:</span>
<span class="sd">        sp (array) : sp[lat, lon+1], surface pressure (unit: Pa), (lattice grid data) (north-&gt;south direction (N-&gt;S), for 1*1 grid, the coordinate is like (0.,90.),(1.,90.),(2.,90.),.....(359.,90),(0.,89.),(1.,89.)....)</span>
<span class="sd">        hm (array) : hm[lon, lat], topography/orography data (unit: m) (centered grid data) (N-&gt;S, for 1*1 grid, the coordinate is like (0.5, 89.5), (1.5, 89.5),...(359.5, 89.5), (0.5, 88.5), (1.5, 88.5)...)</span>
<span class="sd">        ets (array) :[lon, lat+1], eastward turbulent surface stress (unit: n/m2) (lattice grid data) (n-&gt;s) . if unit is (n m-2 s), then divide the data with the time step of the data. for example, if daily data were used, then divide 3600s*24h=86400s to get unit of n/m2 . other input parameters is the same as here.</span>
<span class="sd">        nts (array) :[lon, lat+1], northward turbulent surface stress (unit: n/m2) (lattice grid data) (n-&gt;s)</span>
<span class="sd">        egws (array) :[lon, lat+1], eastward gravity wave surface stress (unit: n/m2) (lattice grid data) (n-&gt;s)</span>
<span class="sd">        ngws (array) :[lon, lat+1], northward gravity wave surface stress (unit: n/m2) (lattice grid data) (n-&gt;s)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple :</span>
<span class="sd">            * te (array) : [lon,lat], complex output (x+iy), ellipsoidal torque for ib hypothesis (centered grid data, n-&gt;s) (unit:hadley, 1hu=10**18kg.m.m/s/s=n.m)</span>
<span class="sd">            * ten (array) : [lon,lat], complex output (x+iy), ellipsoidal torque for nib hypothesis (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tm_dp (array) : [lon,lat], complex output (x+iy), mountain torque for ib hypothesis using pressure gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tmn_dp (array) : [lon,lat], complex output (x+iy), mountain torque for nib hypothesis using pressure gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tm_dh (array) : [lon,lat], complex output (x+iy), mountain torque for ib hypothesis using topography gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tmn_dh (array) : [lon,lat], complex output (x+iy), mountain torque for nib hypothesis using topography gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tf (array) : [lon,lat], complex output (x+iy), friction torque (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tg (array) : [lon,lat], complex output (x+iy), gravity wave torque (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tm3_dp (array) : [lon,lat], z component, mountain torque for ib hypothesis using pressure gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tm3n_dp (array) : [lon,lat], z component, mountain torque for nib hypothesis using pressure gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tm3_dh (array) : [lon,lat], z component, mountain torque for ib hypothesis using topography gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tm3n_dh (array) : [lon,lat], z component, mountain torque for nib hypothesis using topography gradient method (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tf3 (array) : [lon,lat], z component, friction torque (centered grid data, n-&gt;s) (unit:hadley)</span>
<span class="sd">            * tg3 (array) : [lon,lat], z component, gravity wave torque (centered grid data, n-&gt;s) (unit:hadley)</span>

<span class="sd">    References:</span>
<span class="sd">         .. [1] Egger B. J. and K. P. Hoinka, Equatorial components of global atmospheric angular momentum: covariance functions, Q. J. R. Meteorol. Soc., Vol. 128, p1137-1157, 2002.</span>
<span class="sd">        .. [2] Egger B. J. and K. P. Hoinka, Mountain torques and the equatorial components of global angular momentum, J. Atmos. Sci., p2319-2331, 2000.</span>
<span class="sd">        .. [3] Egger B. J., K. Weickmann, and K. P. Hoinka, Angular momentum in the global atmospheric circulation, Rev. Geophys., Vol. 45, RG4007, 2007.</span>
<span class="sd">        .. [4] Schindelegger M., J. Bohm and D. Salstein, Seasonal and intraseasonal polar motion variability as deduced from atmospheric torques, J. Geod. Geoinfor., Vol. 1, P89-95, 2012</span>
<span class="sd">        .. [5] Schindelegger M., D. Salsteim and J. Bohm, Recent estimates of Earth-atmosphere interaction torques and their use in studying polar motion variability, J. Geophys. Res., Vol. 118, p4586-4598, 2013.</span>
<span class="sd">        .. [6] Feldstein S. B., The dynamics of atmospherically driven intraseasonal polar motion, J. Atmos. Sci., Vol. 65, P2290-2307,2008.</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`mountain_torque`, :func:`stress_torque`, :func:`eaam_xyz_j2j3`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_torque</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">ets</span><span class="p">,</span> <span class="n">nts</span><span class="p">,</span> <span class="n">egws</span><span class="p">,</span> <span class="n">ngws</span><span class="p">)</span></div>


<div class="viewcode-block" id="torque2lod"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.torque2lod">[docs]</a><span class="k">def</span> <span class="nf">torque2lod</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">torque</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change torque (z axis) to dLOD (length of day)  ( lod(i+1)-lod(i) )</span>

<span class="sd">    Args:</span>
<span class="sd">        dt (float) : Time interval (step) of input array, unit: second</span>
<span class="sd">        torque (array) : Torque in z axis, unit: Hadley, see WFL_TORQUE for details</span>

<span class="sd">    Returns:</span>
<span class="sd">        array: dlod_torque, The corresponding LOD change from input torque, unit: millisecond, ms. Note, this output is == lod(i+1)-lod(i), NOT  lod(i). To get lod(i), please use subroutine :func:`torque2lod_adams`.</span>

<span class="sd">    Notes:</span>
<span class="sd">        dlod_torque(1:2) are integrated directly, while dlod_torque(3:n) are integrated by Simpson integral method.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_torque2lod</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">torque</span><span class="p">)</span></div>


<div class="viewcode-block" id="torque2lod_adams"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.torque2lod_adams">[docs]</a><span class="k">def</span> <span class="nf">torque2lod_adams</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">torque</span><span class="p">,</span> <span class="n">lod0</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Using 4th order Adams-Moulton method to get LOD (length of day) change from torque z</span>

<span class="sd">    args:</span>
<span class="sd">        dt (float) : time interval (step) of input array, unit: second</span>
<span class="sd">        torque (array) : torque[n], torque in z axis, unit: hadley, see wfl_torque for details</span>
<span class="sd">        lod (array): lod[3], the first 3 initial values for ordinary differential equation d(lod0)/dt=torque, unit: ms</span>
<span class="sd">        t (array) :  t[n], time index of input torque</span>

<span class="sd">    returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * lod(n) : the corresponding lod change from input torque, unit: millisecond, ms.</span>
<span class="sd">            * lod_poly(n) :polynomial term of output lod(n). due to numerical integral will cause a polynomial term in the output lod(n) results, we use polynomial fit to remove this polynomial term if you present t and lod_poly at the same time in subroutine wfl_torque2lod_adams.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_torque2lod_adams</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">torque</span><span class="p">,</span> <span class="n">lod0</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_torque2lod_adams</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">torque</span><span class="p">,</span> <span class="n">lod0</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="vd_station_index"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.vd_station_index">[docs]</a><span class="k">def</span> <span class="nf">vd_station_index</span><span class="p">(</span><span class="n">nlat</span><span class="p">,</span> <span class="n">site_lon</span><span class="p">,</span> <span class="n">site_lat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get station index for calculation of vertical displacement of special station by using spherical harmonic method. The output of this subroutine will be used by :func:`load_vert_def` or :func:`cs2vertical`.</span>

<span class="sd">    Args:</span>
<span class="sd">        nlat (int) :  or degree n, is the center grid # in latitude or the maximum degree n of spherical harmonic coefficients</span>
<span class="sd">        site_lon (float) : coordinate longitude (0~360deg) of the station. Unit: degree</span>
<span class="sd">        site_lat (float) : coordinate latitude(-90~90deg) of the station. Unit: degree</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * depart_lon, alat[nlat] : see details in subroutine :func:`cs2vertical`. Unit: degree</span>
<span class="sd">            * idx_lon, idx_lat : Index of the input station location in the output of :func:load_vert_def` or :func:`cs2vertical`. For example, the output of :func:load_vert_def` or :func:`cs2vertical` --&gt; u(idx_lon,idx_lat) is the input station vertical displacement</span>

<span class="sd">    Notes:</span>
<span class="sd">        If you want to get the vertical deformation of a special GPS station located at (site_lon, site_lat) then do follow:</span>

<span class="sd">        1.use global atmosphere/hydrology/ocean pressure data (equivalent water height) and :func:`fun_exp_fft` to get spherical harmonic coefficients c and s of the equivalent water heigh;</span>
<span class="sd">        2. use :func:`vd_station_index` to get the output parameters of depart_lon, alat, idx_lon, and idx_lat;</span>
<span class="sd">        3. use :func:`cs2vertical` with step 2 output parameters to get vertical deformation u, then u(idx_lon,idx_lat) is the vertical deformation of the above GPS station.</span>

<span class="sd">    reference:</span>
<span class="sd">        .. [1] Mangiarotti, S., A. Cazenave, Annual vertical crustal motions predicted from surface mass redistribution and observed by space geodesy, J Geophys Res, Vol. 106, B3, P4277-4291, 2001.</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`cs2vertical`, :func:`load_vert_def`, :func:`func_sum`, :func:`func_sum_fft`, :func:`func_exp`, :func:`func_exp_fft`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_vd_station_index</span><span class="p">(</span><span class="n">nlat</span><span class="p">,</span> <span class="n">site_lon</span><span class="p">,</span> <span class="n">site_lat</span><span class="p">)</span></div>


<div class="viewcode-block" id="wind2tao"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.wind2tao">[docs]</a><span class="k">def</span> <span class="nf">wind2tao</span><span class="p">(</span><span class="n">windu</span><span class="p">,</span> <span class="n">windv</span><span class="p">,</span> <span class="n">air_density</span><span class="o">=</span><span class="mf">1.3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        windu(float): Wind velocity in East direction (unit: m/s)</span>
<span class="sd">        windv(float): Wind velocity in North direction (unit: m/s)</span>
<span class="sd">        air_density (float): air density. Default air_density=1.3km/m3</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * stressu (float): Wind stress in East direction (unit: kg/(m*s**2) , or N*m-2)</span>
<span class="sd">            * stressv (float): Wind stress in North direction (unit: kg/(m*s**2) , or N*m-2)</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function is used for 10m wind in the ocean area.</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Trenberth, et al. (1990): J. Phys. Oceanogr., 20, 1742-1760. Eq. (2)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`windv2tao`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_wind2tao</span><span class="p">(</span><span class="n">windu</span><span class="p">,</span> <span class="n">windv</span><span class="p">,</span> <span class="n">air_density</span><span class="o">=</span><span class="n">air_density</span><span class="p">)</span></div>


<div class="viewcode-block" id="windv2tao"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.windv2tao">[docs]</a><span class="k">def</span> <span class="nf">windv2tao</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get wind stress from wind velocity</span>

<span class="sd">    Arg:</span>
<span class="sd">        w (float): Wind velocity (unit: m/s)</span>

<span class="sd">    Return:</span>
<span class="sd">        float : tao, Wind stress (unit: kg/(m*s**2) , or N*m-2)</span>

<span class="sd">    Notes:</span>
<span class="sd">        Wind stress tao has the same direction as wind vector W, the input in the above function is absolute value (:math:`|W|`) of wind vector W, without consideration of wind direction.</span>

<span class="sd">        east wind (u) and north wind (v) should be first combine to get W at each grid, after that change :math:`|W|` to tao, and then use the direction of W to get tao(u), tao(v).</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Gill A. E., Atmosphere-Ocean Dynamics, Academic press, London, 1982, p29, Eq. (2.4.2)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; windv2tao(4.3) # 0.02542375</span>
<span class="sd">        &gt;&gt;&gt; windv2tao(10) # 0.155</span>
<span class="sd">    See Also:</span>
<span class="sd">        :func:`wfl_wind2tao`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_windv2tao</span><span class="p">(</span><span class="n">v</span><span class="p">)</span></div>


<div class="viewcode-block" id="x2prograd"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.x2prograd">[docs]</a><span class="k">def</span> <span class="nf">x2prograd</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">fai1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">fai2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change excitation function in Earth&#39;s rotation domain to prograde and retrograde format</span>

<span class="sd">    Args:</span>
<span class="sd">        a1 (float) :The amplitude of excitation function x1</span>
<span class="sd">        fai1 (float) :The phase of excitation function x1 (unit: degree)</span>
<span class="sd">        a2 (float) :The amplitude of excitation function x2</span>
<span class="sd">        fai2 (float) :The phase of excitation function x2 (unit: degree)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            *a_pro (float): The amplitude for prograde component</span>
<span class="sd">            *fai_pro (float): The phase for prograde component</span>
<span class="sd">            *a_retro (float): The amplitude for retrograde component</span>
<span class="sd">            *fai_retro (float): The phase for retrograde component</span>

<span class="sd">    Notes:</span>
<span class="sd">        Equation:  change :math:`x_1 + ix_2 = a_1 \\cos(w_t - \\phi_1) + i a_2 \\cos(w_t - \\phi_2)` to :math:`a_{pro} \\exp(i \\phi_{pro}) \\exp(i w_t) + a_{retro} \\exp(i \\phi_{retro}) \\exp(-i w_t)`, here :math:`x_1` and :math:`x_2` are excitation function used in Earth&#39;s rotation domain, and :math:`w` is angular frequency omega. If the model of :math:`x_1` and :math:`x_2` are not like above (maybe sine format, see :func:`harmonic` for transfer to the above format in details )</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`prograd2x0`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_x2prograd</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">fai1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">fai2</span><span class="p">)</span></div>


<div class="viewcode-block" id="prograd2x0"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.prograd2x0">[docs]</a><span class="k">def</span> <span class="nf">prograd2x0</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">fai1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">fai2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change excitation function in Earth&#39;s rotation domain to prograde and retrograde format</span>

<span class="sd">    Args:</span>
<span class="sd">        a1 (float) : The amplitude of excitation function x1</span>
<span class="sd">        fai1 (float) : The phase of excitation function x1 (unit: degree)</span>
<span class="sd">        a2 (float) : The amplitude of excitation function x2</span>
<span class="sd">        fai2 (float) : The phase of excitation function x2 (unit: degree)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * f1 (float) :The real part for prograde component</span>
<span class="sd">            * f2 (float) :The image part for prograde component</span>
<span class="sd">            * g1 (float) :The real part for retrograde component</span>
<span class="sd">            * g2 (float) :The image part for retrograde component</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`x2prograd`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_x2prograd_0</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">fai1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">fai2</span><span class="p">)</span></div>


<div class="viewcode-block" id="angle_dis"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.angle_dis">[docs]</a><span class="k">def</span> <span class="nf">angle_dis</span><span class="p">(</span><span class="n">fai1</span><span class="p">,</span> <span class="n">lambda1</span><span class="p">,</span> <span class="n">fai2</span><span class="p">,</span> <span class="n">lambda2</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="s1">&#39;radian&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate geocentric angle (or corresponding Earth&#39;s surface distance) between two points</span>

<span class="sd">    Args:</span>
<span class="sd">        fai1, lambda1 (float) : First point&#39;s coordinate (latitude, longitude) (unit: degree, -90~90, 0~360)</span>
<span class="sd">        fai2, lambda2 (float) : Second point&#39;s coordinate (latitude, longitude) (unit: degree, -90~90, 0~360)</span>
<span class="sd">        ch (string) : Must be character. If ch=&#39;angle&#39;, then return the geocentric angle (unit: radian) to angle_dis_result. If ch=&#39;distance&#39;, then return the corresponding Earth&#39;s surface distance (unit: meter) to angle_dis_result.</span>

<span class="sd">    Return:</span>
<span class="sd">        angle_dis_result (float), Geocentric angle (unit: radian) or corresponding Earth&#39;s surface distance (unit: meter).</span>

<span class="sd">    Notes:</span>
<span class="sd">        The formula used here (see below for detail) is the same as used in :func:`sphere_len`, but with the different formal.</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\cos(\\phi)=\\cos(\\theta_{1})\\cos(\\theta_{2})+sin(\\theta_{1})sin(\\theta_{2})\\cos(\\lambda_{1}-\\lambda_{2})</span>

<span class="sd">        :math:`\\phi` is geocentric angle between two points, and :math:`\\theta_{1}`,:math:`\\theta_{2}` are colatitude of :math:`\\phi_{1}` and :math:`\\phi_{2}` respectively. The Earth&#39;s radius adopted here is 6371012m.</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; angle_dis(0., 0., 0., 2.) # 0.0349065850399</span>
<span class="sd">        &gt;&gt;&gt; angle_dis(0., 0., 0., 2., ch=&#39;distance&#39;) # 222390.272168</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_angle_dis</span><span class="p">(</span><span class="n">fai1</span><span class="p">,</span> <span class="n">lambda1</span><span class="p">,</span> <span class="n">fai2</span><span class="p">,</span> <span class="n">lambda2</span><span class="p">,</span> <span class="n">ch</span><span class="o">=</span><span class="n">ch</span><span class="p">)</span></div>


<div class="viewcode-block" id="eaam_xyz_slp"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.eaam_xyz_slp">[docs]</a><span class="k">def</span> <span class="nf">eaam_xyz_slp</span><span class="p">(</span><span class="n">slp</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">is_sp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        slp (array) : slp[lon, lat], Sea level pressure/surface pressure. Sea level pressure if is_sp is not presented. Surface pressure if is_sp is presented, and is_sp==.true.   (North-&gt;South) (unit: mbar. Note: 1mbar==1hPa)</span>
<span class="sd">        hm (array) : hm[lon, lat], Topography data or elevation at each points (North-&gt;South) (unit: m)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * fp (array) : [lon, lat], Mass term for equatorial component with IB-hypothesis.(unit:10-7)</span>
<span class="sd">            * fpn (array) : [lon, lat], Mass term for equatorial component with non IB-hypothesis. (unit:10-7)</span>
<span class="sd">            * f3p (array) : [lon, lat], Mass term for axial component with IB-hypothesis.(unit:10-7)</span>
<span class="sd">            * f3pn (array) : [lon, lat], Mass term for axial component with non IB-hypothesis.(unit:10-7)</span>
<span class="sd">            * pmn (array) : [lon, lat], Total mass of atmosphere. (non-IB) (unit:1020 g, not kg)</span>
<span class="sd">            * pm (array) : [lon, lat], Total mass of atmosphere. (IB) (unit:1020 g, not kg)</span>
<span class="sd">            * xypn (array) : [lon, lat], Mass center of x and y coordinate (non-IB) (unit: cm)</span>
<span class="sd">            * xyp (array) : [lon, lat], Mass center of x and y coordinate (IB) (unit: cm)</span>
<span class="sd">            * zpn (array) : [lon, lat], Mass center of z coordinate( non-IB) (unit: cm)</span>
<span class="sd">            * zp (array) : [lon, lat], Mass center of z coordinate( IB) (unit: cm)</span>
<span class="sd">            * j2n (array) : [lon, lat], J2 value (non-IB) (unit: 10-10)</span>
<span class="sd">            * j2 (array) : [lon, lat], J2 value (IB) (unit: 10-10)</span>
<span class="sd">            * j3n (array) : [lon, lat], J3 value (non-IB) (unit: 10-10)</span>
<span class="sd">            * j3 (array) : [lon, lat], J3 value (IB) (unit: 10-10)</span>

<span class="sd">    Notes:</span>
<span class="sd">        Note: The better choose is to use Surface Pressure(SP) as the input but not Sea Level Pressure(SLP). Due to here we only use approximate equation (see below) to calculate SP from SLP, this will cause minor error at high altitude area. Especially, the total mass of atmosphere is not correct when use SLP as input, while it&#39;s correct when use SP as input. Other outputs are also have minor errors when use SLP as input.</span>

<span class="sd">        All input data must be sorted from North to South and at the grid center, order of data may like below (longitude, latitude): (1.25,88.75), (3.75,88.75), ...,(358.75,88.75), (1.25,86.25),(3.75,86.25),.....</span>

<span class="sd">        If the data is at grid lattice not at the grid center, then you can use INTERPOLATE2D and INTERPOLATE3D to interpolate the original field first, then  use the interpolation field in EAAM_XYZ_SLP.</span>

<span class="sd">        When calculate surface pressure from sea level pressure, we use topography height and an approximate equation like below:</span>
<span class="sd">        sp=slp*(1-0.0065*h/288.15)**(9.81/(287.04*0.0065))</span>
<span class="sd">        where sp,slp,h means surface pressure, sea level pressure and topography height. If you want to get more accuracy output, please choose EAAM_XYZ_J2J3, but in this case you must provide geopotential height data as input.</span>

<span class="sd">        Note: all the parameters about Earth is Eubank&#39;s value like below:</span>
<span class="sd">        CC   =7.1236 D44       Earth principal moment of inertia</span>
<span class="sd">        CCM=7.1236 D44</span>
<span class="sd">        CA   =0.003664*CC     C - A</span>

<span class="sd">        Barnes&#39;s Earth parameter (not used here) :</span>
<span class="sd">        CC=7.04D44</span>
<span class="sd">        CCM=7.1236 D44</span>
<span class="sd">        CA=0.00333*CC</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Barnes R. T. H., Atmospheric angular momentum fluctuations, length of day changes and polar motion, Proc. R. Soc. Lond. A, 387,31-73, 1983.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_eaam_xyz_slp</span><span class="p">(</span><span class="n">slp</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">is_sp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="eaam_xyz_wind"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.eaam_xyz_wind">[docs]</a><span class="k">def</span> <span class="nf">eaam_xyz_wind</span><span class="p">(</span><span class="n">ltrop</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">slp</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">hm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">en</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get Effective Atmospheric Angular Momentum (EAAM), only for wind-term</span>

<span class="sd">    Args:</span>
<span class="sd">        ltrop (int) : Lays great and equal (&gt;=) 10mbar(1000-&gt;10mbar, include 10mbar. Note: 1mbar==1hPa)</span>
<span class="sd">        pl (array) : [lay], Pressure values in each vertical lay (such as: 1000., 850., 700.,...,30.10.,...) (unit: mbar)</span>
<span class="sd">        u (array) : [lon,lat,lay], East-ward wind velocities at the each levels (North-&gt;South)  (unit: m/s)</span>
<span class="sd">        v (array) : [lon,lat,lay], North-ward wind velocities at the each levels (North-&gt;South) (unit: m/s)</span>
<span class="sd">        slp (array) : [lon,lat], Sea level pressure (North-&gt;South) (unit: mbar). The slp,hm,and z must be presented at the same time. If they are not presented, then calculate wind term of effective angular momentum using &quot;BP&quot; method; otherwise using &quot;SP&quot; method to calculate effective angular momentum.</span>
<span class="sd">        hm(array) : [lon,lat], Topography data or elevation at each points (North-&gt;South) (unit: m)</span>
<span class="sd">        z[lon,lat,lay]:Geo-potential height at each level from 1000mb to top (North-&gt;South)  (unit: m)</span>
<span class="sd">        en (bool) : default False, call :func:`eaam_xyz_wind`, True for :func:`eaam_xyz_wind_en`</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * fw (array) : [lon,lat], Wind term for equatorial component (total 1000mbar-&gt;top).(unit:10-7)</span>
<span class="sd">            * fwl (array) : [lon,lat], Wind term for equatorial component but in upper troposphere alone(10mbar-&gt;top).(unit:10-7)</span>
<span class="sd">            * f3w (array) : [lon,lat], Wind term for axial component (total 1000mbar-&gt;top).(unit:10-7)</span>
<span class="sd">            * f3wl (array) : [lon,lat], Wind term for axial component but in upper troposphere alone(10mbar-&gt;top).(unit:10-7)</span>

<span class="sd">    Notes:</span>
<span class="sd">        All input data must be sorted from North to South and at the grid center, order of data may like below (longitude, latitude): (1.25,88.75), (3.75,88.75), ...,(358.75,88.75), (1.25,86.25),(3.75,86.25),.....</span>

<span class="sd">        If the data is at grid lattice not at the grid center, then you can use INTERPOLATE2D and INTERPOLATE3D to interpolate the original field first, then  use the interpolation field in EAAM_XYZ_WIND.</span>

<span class="sd">        Note: all the parameters about Earth is Eubank&#39;s value like below:</span>
<span class="sd">        CC   =7.1236 D44       Earth principal moment of inertia</span>
<span class="sd">        CCM=7.1236 D44</span>
<span class="sd">        CA   =0.003664*CC     C - A</span>

<span class="sd">        Barnes&#39;s Earth parameter (not used here) :</span>
<span class="sd">        CC=7.04D44</span>
<span class="sd">        CCM=7.1236 D44</span>
<span class="sd">        CA=0.00333*CC</span>

<span class="sd">        When calculate wind term or relative angular momentum, use &quot;SP&quot; method which means put the first level (1000mbar) wind as the surface wind in the mountain; use BP method, which do not consider the land surface and calculate all the wind AAM integral from 1000mbar to top.</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Barnes R. T. H., Atmospheric angular momentum fluctuations, length of day changes and polar motion, Proc. R. Soc. Lond. A, 387,31-73, 1983.</span>


<span class="sd">    See Also:</span>
<span class="sd">        :func:`eaam_xyz_slp`, :func:`eaam_xyz_j2j3`, :func:`ewam_xyz_j2j3`, :func:`eaam_xyz_wind_en`</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_eaam_xyz_wind_en</span> <span class="k">if</span> <span class="n">en</span> <span class="k">else</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_eaam_xyz_wind</span>
    <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">z</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">ltrop</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">ltrop</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">slp</span><span class="o">=</span><span class="n">slp</span><span class="p">,</span> <span class="n">hm</span><span class="o">=</span><span class="n">hm</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">)</span></div>


<div class="viewcode-block" id="eam_barnes2eubanks"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.eam_barnes2eubanks">[docs]</a><span class="k">def</span> <span class="nf">eam_barnes2eubanks</span><span class="p">(</span><span class="n">eam</span><span class="p">,</span> <span class="n">cha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change Barnes&#39;s EAAM, EWAM or EOAM to Eubanks&#39;s EAAM, EWAM or EOAM</span>

<span class="sd">    Args:</span>
<span class="sd">        eam (float) : Effective angular Momentum (unit: free)</span>
<span class="sd">        cha (string): cha eaqual one of follow character, &#39;xp&#39;, &#39;xc&#39;, &#39;yp&#39;, &#39;yc&#39; , &#39;zp&#39;, &#39;zc&#39;</span>

<span class="sd">    Returns:</span>
<span class="sd">        float: eam_results, Effective Angular Momentum (unit: same as input)</span>

<span class="sd">    Notes:</span>
<span class="sd">        cha denote X,Y or Z coordinate for pressure (P) and current (C) term</span>
<span class="sd">        Change Barnes&#39;s EAAM or EWAM or EOAM to Eubanks&#39;s EAAM or EWAM or EOAM</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`eam2masms`, :func:`masms2eam`, :func:`am2eam`</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;xp&#39;</span><span class="p">,</span> <span class="s1">&#39;xc&#39;</span><span class="p">,</span> <span class="s1">&#39;yp&#39;</span><span class="p">,</span> <span class="s1">&#39;yc&#39;</span><span class="p">,</span> <span class="s1">&#39;zp&#39;</span><span class="p">,</span> <span class="s1">&#39;zc&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cha should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">conds</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_eam_barnes2eubanks</span><span class="p">(</span><span class="n">eam</span><span class="p">,</span> <span class="n">cha</span><span class="p">)</span></div>


<div class="viewcode-block" id="eam2masms"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.eam2masms">[docs]</a><span class="k">def</span> <span class="nf">eam2masms</span><span class="p">(</span><span class="n">xin</span><span class="p">,</span> <span class="n">cha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Change effective angular momentum(unit: 1.0d-7 rad) to unit mas (for x,y) and ms (for z)</span>

<span class="sd">    Args:</span>
<span class="sd">        xin (float) : Effective Angular Momentum (unit: 1.0d-7 rad )</span>
<span class="sd">        cha (string) : cha is one of follow character, &#39;x&#39;,  &#39;y&#39; , &#39;z&#39;</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Polar Motion value (unit: mas) or Length of Day value (unit: ms)</span>

<span class="sd">    Notes:</span>
<span class="sd">        cha denote X,Y or Z coordinate</span>
<span class="sd">        This function only used in the Earth&#39;s Rotation domain, which change Effective Angular Momentum to polar motion (unit: mas) or Length of Day (unit: ms).</span>
<span class="sd">        mas=milli-arcsencod, ms=millisecond</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Barnes R. T. H., Atmospheric angular momentum fluctuations, length of day changes and polar motion, Proc. R. Soc. Lond. A, 387,31-73, 1983.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cha should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">conds</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_eam2masms</span><span class="p">(</span><span class="n">xin</span><span class="p">,</span> <span class="n">cha</span><span class="p">)</span></div>


<div class="viewcode-block" id="ewam_xyz_j2j3"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.ewam_xyz_j2j3">[docs]</a><span class="k">def</span> <span class="nf">ewam_xyz_j2j3</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">evp</span><span class="p">,</span> <span class="n">runoff</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">grid_status</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;ocean_zero&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get Effective Water Angular Momentum (EWAM), geocenter, J2 and J3</span>

<span class="sd">    Args:</span>
<span class="sd">        pre (array) : [lon,lat+1], Global precipitation (North-&gt;South) (unit: mm).  Note, pre, evp and runoff must be with size of (lon,lat+1), if grid_status==&#39;center&#39;, you can only use (lon,lat) to store the data; if grid_status==&#39;lattice&#39;, then you will use (lon,lat+1) to store the data, and in the inner of subroutine, pre, evp and runoff will be interpolated into grid center values.  When output, the value is centered at (lon,lat) and with unit of cm.</span>
<span class="sd">        evp (array) : [lon,lat+1], Global evaporation (North-&gt;South) (unit: mm). see note above.  When output, the value is centered at (lon,lat) and with unit of cm.</span>
<span class="sd">        runoff (array) [lon,lat+1], Land runoff (North-&gt;South) (unit: mm). see note above. When output, the value is centered at (lon,lat) and with unit of cm.</span>
<span class="sd">        hm (array) : [lon,lat] :Topography data or elevation at each points (unit: m)</span>
<span class="sd">        grid_status (string) : status of the grid format, grid_status is case-insensitive. If grid_status==&#39;center&#39;, then the input pre, evp and runoff will be taken as grid center data with size of (lon,lat); if grid_status==&#39;lattice&#39;, then the input pre, evp and runoff will be taken as grid lattice data with size of (lon,lat+1) and will be interpolated to the grid center values in the inner of this subroutine .</span>
<span class="sd">        method (string) : If method==&#39;ocean_zero&#39;, then the total water change in the ocean are set to 0.0. If others, then the total water change in ocean are defined as  pre(i,j)-runoff_ocean-evp(i,j), where runoff_ocean is  sum of -runoff(i,j) in land divide ocean area, i.e., the mean runoff in the ocean.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * fp (array) : [lon,lat], Mass term for equatorial component with IB-hypothesis.(unit:10e-7). Here IB means total water in the ocean will be averaged as a single layer in the ocean.</span>
<span class="sd">            * fpn (array) : [lon,lat], Mass term for equatorial component with non IB-hypothesis. (unit:10e-7)</span>
<span class="sd">            * f3p (array) : [lon,lat], Mass term for axial component with IB-hypothesis.(unit:10e-7)</span>
<span class="sd">            * f3pn (array) : [lon,lat], Mass term for axial component with non IB-hypothesis.(unit:10e-7)</span>
<span class="sd">            * pmn (array) : [lon,lat], Total mass of atmosphere. (non-IB) (unit:10e20 g, not kg)</span>
<span class="sd">            * pm (array) : [lon,lat], Total mass of atmosphere. (IB) (unit:10e20 g, not kg)</span>
<span class="sd">            * xypn (array) : [lon,lat], Mass center of x and y coordinate (non-IB) (unit: cm)</span>
<span class="sd">            * xyp (array) : [lon,lat], Mass center of x and y coordinate (IB) (unit: cm)</span>
<span class="sd">            * zpn (array) : [lon,lat], Mass center of z coordinate( non-IB) (unit: cm)</span>
<span class="sd">            * zp (array) : [lon,lat], Mass center of z coordinate( IB) (unit: cm)</span>
<span class="sd">            * j2n (array) : [lon,lat], J2 value (non-IB) (unit: 10e-10)</span>
<span class="sd">            * j2 (array) : [lon,lat], J2 value (IB) (unit: 10e-10)</span>
<span class="sd">            * j3n (array) : [lon,lat], J3 value (non-IB) (unit: 10e-10)</span>
<span class="sd">            * j3 (array) : [lon,lat], J3 value (IB) (unit: 10e-10)</span>

<span class="sd">    Notes:</span>
<span class="sd">        All input data must be sorted from North to South, order of data may like below (longitude, latitude): (0,90), (1,90), (2,90),...,(359,90), (0,89),(1,89),.....</span>

<span class="sd">        Note: all the parameters about Earth is Eubank&#39;s value like below:</span>
<span class="sd">        CC   =7.1236 D44       Earth principal moment of inertia</span>
<span class="sd">        CCM=7.1236 D44</span>
<span class="sd">        CA   =0.003664*CC     C - A</span>

<span class="sd">        Barnes&#39;s Earth parameter (not used here) :</span>
<span class="sd">        CC=7.04D44</span>
<span class="sd">        CCM=7.1236 D44</span>
<span class="sd">        CA=0.00333*CC</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Barnes R. T. H., Atmospheric angular momentum fluctuations, length of day changes and polar motion, Proc. R. Soc. Lond. A, 387,31-73, 1983.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_ewam_xyz_j2j3</span><span class="p">(</span><span class="n">pre</span><span class="p">,</span> <span class="n">evp</span><span class="p">,</span> <span class="n">runoff</span><span class="p">,</span> <span class="n">hm</span><span class="p">,</span> <span class="n">grid_status</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">)</span></div>


<div class="viewcode-block" id="gauss_grid"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.gauss_grid">[docs]</a><span class="k">def</span> <span class="nf">gauss_grid</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot; Get Gauss grid coordinate 192*94 in longitude*latitude</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * gauss_lon (192): Gauss grid longitude coordinate</span>
<span class="sd">            * gauss_lat (94): Gauss grid latitude coordinate</span>
<span class="sd">            * gauss_lat_edges (95): Gauss grid latitude edges coordinate</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_gauss_grid</span><span class="p">()</span></div>


<div class="viewcode-block" id="geocenter"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.geocenter">[docs]</a><span class="k">def</span> <span class="nf">geocenter</span><span class="p">(</span><span class="n">zlat_s</span><span class="p">,</span> <span class="n">zlat_n</span><span class="p">,</span> <span class="n">zlon_w</span><span class="p">,</span> <span class="n">zlon_e</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate geocenter variation caused by mass change at a grid</span>

<span class="sd">    Args:</span>
<span class="sd">        zlat_s (float) : Latitude of grid&#39;s southern lattice (unit: degree -90~90)</span>
<span class="sd">        zlat_n (float) : Latitude of grid&#39;s northern lattice (unit: degree -90~90)</span>
<span class="sd">        zlon_w (float) : Longitude of grid&#39;s western lattice (unit: degree 0~360)</span>
<span class="sd">        zlon_e (float) : Longitude of grid&#39;s eastern lattice (unit: degree 0~360)</span>
<span class="sd">        rho (float) : Density (unit: kg/m**3)</span>
<span class="sd">        r1 (float) : Radius of calculated volume (lower one or  benchmark) (unit: m),  see comment for details</span>
<span class="sd">        r2 (float) : Radius of calculated volume (higher one or benchmark plus changes) (unit: m),  see comment for details</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * x (float) : Geocenter displacement in x direction (unit: m)</span>
<span class="sd">            * y (float) : Geocenter displacement in y direction (unit: m)</span>
<span class="sd">            * z (float) : Geocenter displacement in z direction (unit: m)</span>

<span class="sd">    Notes:</span>
<span class="sd">        If r2&gt;r1, it is easy to understand, if r2&lt;r1, it means a geocenter change in opposite direction. Usually, we calculate geocenter from global mass changes, such as from Sea Surface Height (SSH) changes, at this case, we only know the SSH variations or :math:`\\Delta_{ssh}`. To calculate geocenter variations caused by :math:`\\Delta_{ssh}` which may be positive or negative, we can define r1 as the Earth&#39;s average radius Re (r1=Re), and :math:`r2=Re+\\Delta_{ssh}`. Here, r2 may greater than r1, or r2 may smaller then r1.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_geocenter</span><span class="p">(</span><span class="n">zlat_s</span><span class="p">,</span> <span class="n">zlat_n</span><span class="p">,</span> <span class="n">zlon_w</span><span class="p">,</span> <span class="n">zlon_e</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span></div>


<div class="viewcode-block" id="masms2eam"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.masms2eam">[docs]</a><span class="k">def</span> <span class="nf">masms2eam</span><span class="p">(</span><span class="n">xin</span><span class="p">,</span> <span class="n">cha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change Polar Motion (unit: mas) or Length of Day (unit: ms) to effective angular momentum (unit: 1.0d-7 rad)</span>
<span class="sd">    Args:</span>
<span class="sd">        xin (float) : Polar Motion (unit: mas) or Length of Day (unit: ms)</span>
<span class="sd">        cha (string) : cha is one of follow character, &#39;x&#39;,  &#39;y&#39; , &#39;z&#39;</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Effective Angular Momentum (unit: 1.0d-7 rad )</span>

<span class="sd">    Notes:</span>
<span class="sd">        cha denote X,Y or Z coordinate</span>
<span class="sd">        This function only used in Earth Rotation domain, which change polar motion or Length of Day to EAM.</span>
<span class="sd">        mas=milli-arcsencod, ms=millisecond</span>

<span class="sd">    Reference:</span>
<span class="sd">        .. [1] Barnes R. T. H., Atmospheric angular momentum fluctuations, length of day changes and polar motion, Proc. R. Soc. Lond. A, 387,31-73, 1983.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cha should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">conds</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_masms2eam</span><span class="p">(</span><span class="n">xin</span><span class="p">,</span> <span class="n">cha</span><span class="p">)</span></div>

<div class="viewcode-block" id="oam_int"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.oam_int">[docs]</a><span class="k">def</span> <span class="nf">oam_int</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">,</span><span class="n">zlat_s</span><span class="p">,</span><span class="n">zlat_n</span><span class="p">,</span><span class="n">zlon_w</span><span class="p">,</span><span class="n">zlon_e</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate grid ocean angular momentum use integral calculation</span>

<span class="sd">    Args:</span>
<span class="sd">        rho (float) : Ocean water&#39;s density at grid (unit: kg/m**3)</span>
<span class="sd">        r1 (float) : The distance from Earth center to the grid lower edge in vertical (or z) direction (unit: m)</span>
<span class="sd">        r2 (float) : The distance from Earth center to the grid higher edge in vertical (or z) direction (unit: m) (r1&lt;=r2)</span>
<span class="sd">        zlat_s (float) : Latitude of grid&#39;s southern lattice (unit: degree -90~90) (zlat_s&lt;zlat_n, south-&gt;north)</span>
<span class="sd">        zlat_n (float) : Latitude of grid&#39;s northern lattice (unit: degree -90~90) (zlat_s&lt;zlat_n, south-&gt;north)</span>
<span class="sd">        zlon_w (float) : Longitude of grid&#39;s western lattice (unit: degree 0~360) (zlon_w&lt;zlon_e, west-&gt;east)</span>
<span class="sd">        zlon_e (float) : Longitude of grid&#39;s eastern lattice (unit: degree 0~360) (zlon_w&lt;zlon_e, west-&gt;east)</span>
<span class="sd">        u (float) : Ocean current velocity in latitudinal direction (East is positive) (unit: m/s)</span>
<span class="sd">        v (float) : Ocean current velocity in meridional direction (North is positive) (unit: m/s)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * xoamp, yoamp, zoamp (float) Planetary angular momentum (or mass term) in x, y and z direction (unit: kg.m**2/s)</span>
<span class="sd">            * xoamc, yoamc, zoamc (float) Relative angular momentum (or current term) in x,y and z direction (unit: kg.m**2/s)</span>

<span class="sd">    Notes:</span>
<span class="sd">        :func:`oam_int` is more accuracy than simple method :func:`oam_simple`. If you only provide rho but no u and v, then you can only get mass term; if you only provide u and v but no rho, then you can only get current term; if all provide, you can get all output. If you do not provide rho, u, or v, then set them to 0.0d0.</span>


<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_oam_int</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">r1</span><span class="p">,</span><span class="n">r2</span><span class="p">,</span><span class="n">zlat_s</span><span class="p">,</span><span class="n">zlat_n</span><span class="p">,</span><span class="n">zlon_w</span><span class="p">,</span><span class="n">zlon_e</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="oam_simple"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.oam_simple">[docs]</a><span class="k">def</span> <span class="nf">oam_simple</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">zlat</span><span class="p">,</span><span class="n">zlon</span><span class="p">,</span><span class="n">dlat</span><span class="p">,</span><span class="n">dlon</span><span class="p">,</span><span class="n">dr</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Calculate grid ocean angular momentum use simple calculation</span>

<span class="sd">    Args:</span>
<span class="sd">        rho (float) : Ocean water&#39;s density at grid (unit: kg/m**3)</span>
<span class="sd">        r1 (float) : The distance from Earth center to the grid lower edge in vertical (or z) direction (unit: m)</span>
<span class="sd">        r2 (float) : The distance from Earth center to the grid higher edge in vertical (or z) direction (unit: m) (r1&lt;=r2)</span>
<span class="sd">        zlat (float) : Latitude coordinate of grid center (unit: degree -90~90)</span>
<span class="sd">        zlon (float) : Longitude coordinate of grid center (unit: degree 0~360)</span>
<span class="sd">        dlon (float) : Longitude length (or interval) of grid (unit: degree 0~360)</span>
<span class="sd">        dr (float) : The z (or vertical) distance of grid (unit: m)</span>
<span class="sd">        u (float) : Ocean current velocity in latitudinal direction (East is positive) (unit: m/s)</span>
<span class="sd">        v (float) : Ocean current velocity in meridional direction (North is positive) (unit: m/s)</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple</span>
<span class="sd">            * xoamp, yoamp, zoamp (float) Planetary angular momentum (or mass term) in x, y and z direction (unit: kg.m**2/s)</span>
<span class="sd">            * xoamc, yoamc, zoamc (float) Relative angular momentum (or current term) in x,y and z direction (unit: kg.m**2/s)</span>

<span class="sd">    Notes:</span>
<span class="sd">        :func:`oam_int` is more accuracy than simple method :func:`oam_simple`. If you only provide rho but no u and v, then you can only get mass term; if you only provide u and v but no rho, then you can only get current term; if all provide, you can get all output. If you do not provide rho, u, or v, then set them to 0.0d0.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_oam_simple</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">zlat</span><span class="p">,</span><span class="n">zlon</span><span class="p">,</span><span class="n">dlat</span><span class="p">,</span><span class="n">dlon</span><span class="p">,</span><span class="n">dr</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span></div>

<div class="viewcode-block" id="ocean_densiy"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.ocean_densiy">[docs]</a><span class="k">def</span> <span class="nf">ocean_densiy</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">lat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate ocean water density from ocean depth, salinity and temperature field</span>

<span class="sd">    Args:</span>
<span class="sd">        s (float) :Salinity (unit: psu)</span>
<span class="sd">        c (float) :Temperature (unit: degC)</span>
<span class="sd">        depth (float) :Ocean depth (unit: m)</span>
<span class="sd">        lat (float) : Latitude (unit: deg, -90~90). Gravity variation with latitude is considered here.</span>

<span class="sd">    Return:</span>
<span class="sd">        float : Ocean water&#39;s density (unit: kg/m**3)</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_ocnden</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">depth</span><span class="p">,</span><span class="n">lat</span><span class="o">=</span><span class="n">lat</span><span class="p">)</span></div>


<div class="viewcode-block" id="pm2xy"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.pm2xy">[docs]</a><span class="k">def</span> <span class="nf">pm2xy</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">pm</span><span class="p">,</span> <span class="n">cha</span><span class="o">=</span><span class="s1">&#39;mas&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change Polar Motion data PMx and PMy to excitation fields chi_x,chi_y</span>

<span class="sd">    Args:</span>
<span class="sd">        dt (float) :  Time interval of vector (or array) pm (unit: days)</span>
<span class="sd">        pm (array) :  pm[n], Polar motion data (complex, real part is x component, image part is y component) (unit: mas==arcsecond/1000. ) (the direction of x is Greenwich and y is 90 west)</span>
<span class="sd">        cha (string) : If cha==&#39;mas&#39; or cha==&#39;MAS&#39;, then chi_xy has unit of mas; if cha==&#39;e-7&#39; or cha==&#39;E-7&#39;, then the unit of chi_xy is e-7.</span>


<span class="sd">    Return:</span>
<span class="sd">        array : chi_xy (n), Excitation fields (complex), real and image part is x and y component respectively (unit: mas or e-7) (the direction of chi_x is Greenwich and chi_y is 90 east)</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;mas&#39;</span><span class="p">,</span> <span class="s1">&#39;e-7&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">cha</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">conds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cha should be in [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">conds</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_pm2xy</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">pm</span><span class="p">,</span> <span class="n">cha</span><span class="p">)</span></div>

<div class="viewcode-block" id="prograd2x_0"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.prograd2x_0">[docs]</a><span class="k">def</span> <span class="nf">prograd2x_0</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Change prograde and retrograde format to excitation function in Earth&#39;s rotation domain</span>

<span class="sd">    Args:</span>
<span class="sd">        f1 (float) :The real part for prograde component</span>
<span class="sd">        f2 (float) :The image part for prograde component</span>
<span class="sd">        g1 (float) :The real part for retrograde component</span>
<span class="sd">        g2 (float) :The image part for retrograde component</span>


<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * a1 (float) : The amplitude of excitation function x1</span>
<span class="sd">            * fai1 (float) : The phase of excitation function x1 (unit: degree)</span>
<span class="sd">            * a2 (float) : The amplitude of excitation function x2</span>
<span class="sd">            * fai2 (float) : The phase of excitation function x2 (unit: degree)</span>

<span class="sd">    See Also:</span>
<span class="sd">        :func:`x2prograd`, :func:`prograd2x0`</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_prograd2x_0</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">)</span></div>


<div class="viewcode-block" id="soda_xyz_st"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.soda_xyz_st">[docs]</a><span class="k">def</span> <span class="nf">soda_xyz_st</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Get x, y and z coordinate of SODA ocean model for salinity and temperature field</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * x360 (360): x coordinate (or longitude) (unit: degree 0~360)</span>
<span class="sd">            * y128 (128): y coordinate (or latitude) (unit: degree -60~60)</span>
<span class="sd">            * yedges (129): y coordinate edges (unit: degree -60~60)</span>
<span class="sd">            * z20 (20): z coordinate (or depth) (unit: m)</span>
<span class="sd">            * zedges (21): z coordinate edges (unit: m)</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_soda_xyz_st</span><span class="p">()</span></div>


<div class="viewcode-block" id="soda_xyz_uvh"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.soda_xyz_uvh">[docs]</a><span class="k">def</span> <span class="nf">soda_xyz_uvh</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Get x, y and z coordinate of SODA ocean model for oceanic current u,v and SSH field</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple:</span>
<span class="sd">            * uvhx (360) :x coordinate (or longitude) (unit: degree 0~360)</span>
<span class="sd">            * uvhy (128) :y coordinate (or latitude) (unit: degree -60~60)</span>
<span class="sd">            * uvhyedges (129) :y coordinate edges (unit: degree -60~60)</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_soda_xyz_uvh</span><span class="p">()</span></div>


<div class="viewcode-block" id="sphere_len"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.sphere_len">[docs]</a><span class="k">def</span> <span class="nf">sphere_len</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">b2</span><span class="p">,</span> <span class="n">l2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate spherical length (or distance) between point a1(b1,l1) and a2(b2,l2) on Earth&#39;s surface</span>

<span class="sd">    Args:</span>
<span class="sd">        b1, l1 (float) : First point&#39;s coordinate (latitude, longitude) (unit: degree, -90~90, 0~360)</span>
<span class="sd">        b2, l2 (float) : Second point&#39;s coordinate (latitude, longitude) (unit: degree, -90~90, 0~360)</span>

<span class="sd">    Return:</span>
<span class="sd">        float : slen, Spherical length (or distance) between two points on Earth&#39;s surface (unit: km )</span>

<span class="sd">    Notes:</span>
<span class="sd">        The formula used here (see below for detail) is the same as used in ANGLE_DIS, but the different formal.</span>

<span class="sd">    .. math::</span>
<span class="sd">        [\\sin(\\phi/2)]^{2}=\\sin((\\phi_{1}-\\phi_{2})/2)^{2}+\\cos(\\phi_{1})\\cos(\\phi_{2}) [\\sin((\\lambda_{1}-\\lambda_{2})/2)]^{2}</span>

<span class="sd">    :math:`\\phi` is geocentric angle between two points, and (:math:`\\phi_{1}, \\lambda_{1}`) and (:math:`\\phi_{2}, \\lambda_{2}`) are (latitude,longitude) of two points respectively.  The Earth&#39;s radius adopted here is 6371.012km.</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_sphere_len</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span><span class="n">l1</span><span class="p">,</span><span class="n">b2</span><span class="p">,</span><span class="n">l2</span><span class="p">)</span></div>

<div class="viewcode-block" id="sphere_len_inv"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.sphere_len_inv">[docs]</a><span class="k">def</span> <span class="nf">sphere_len_inv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">slen_bn</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Give a point and spherical length depart form the point, calculate increase (or decrease) in latitude and longitude</span>

<span class="sd">    Args:</span>
<span class="sd">        b, l (float): First point&#39;s coordinate (latitude, longitude) (unit: degree, -90~90, 0~360)</span>
<span class="sd">        slen (float): Spherical length (or distance) on Earth&#39;s surface (unit: km )</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple : delta_b, delta_l, Increase (or decrease) form first point&#39;s coordinate (latitude, longitude) (unit: degree, -90~90, 0~360).</span>

<span class="sd">    Notes:</span>
<span class="sd">        Because inverse problem is not unique, so we here only give two special case: 1) delta_b=0, and delta_l come from :func:`sphere_len_inv`; 2) delta_l=0 and delta_b come from :func:`sphere_len_inv`. So in subroutine :func:`sphere_len_inv`, we give delta_b and delta_l at the same time, but you must use the two results separately, see example for details.</span>

<span class="sd">    Reference:</span>
<span class="sd">        YAN Haoming, IB response and it&#39;s effect on Earth&#39;s rotation</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; slen = sphere_len(63, 10, 63, 14)</span>
<span class="sd">        &gt;&gt;&gt; print slen</span>
<span class="sd">        &gt;&gt;&gt; 201.893584896</span>
<span class="sd">        &gt;&gt;&gt; res = sphere_len_inv(63, 10, slen)</span>
<span class="sd">        &gt;&gt;&gt; print res</span>
<span class="sd">        &gt;&gt;&gt; (1.815669210053464, 3.9999999999999996)</span>
<span class="sd">        &gt;&gt;&gt; print sphere_len(63, 10, 63, 10 + res[1]) # correct use of inverse result</span>
<span class="sd">        &gt;&gt;&gt; 201.893584896</span>
<span class="sd">        &gt;&gt;&gt; print sphere_len(63, 10, 63-res[0], 10) # correct use of inverse result</span>
<span class="sd">        &gt;&gt;&gt; 201.893584896</span>
<span class="sd">        &gt;&gt;&gt; print sphere_len(63, 10, 63+res[0], 10+res[1]) # misuse !</span>
<span class="sd">        &gt;&gt;&gt; 281.02153828</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_sphere_len_inv</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">slen_bn</span><span class="p">)</span></div>


<div class="viewcode-block" id="volume"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.volume">[docs]</a><span class="k">def</span> <span class="nf">volume</span><span class="p">(</span><span class="n">dlon</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate grid volume of Earth at different oceanic depth or above Earth&#39;s surface.</span>

<span class="sd">    Args:</span>
<span class="sd">        dlon (float): Longitude interval (or length) of the grid (unit: degree)</span>
<span class="sd">        lat1 (float): Co-latitude of northern grid border (0 is north pole, 180 is south pole, unit: degree)</span>
<span class="sd">        lat2 (float): Co-latitude of southern grid border (same as lat1, lat2&gt;lat1)</span>
<span class="sd">        z1 (float): Ocean depth in grid above (positive, unit: m)</span>
<span class="sd">        z2 (float): Ocean depth in grid bottom (positive, z2&gt;z1, unit: m)</span>

<span class="sd">    Return:</span>
<span class="sd">        float : volume_result, Volume of grid (unit: m**3)</span>

<span class="sd">    Notes:</span>
<span class="sd">        If calculate mountain volume, then z1 and z2 are negative.</span>
<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_volume</span><span class="p">(</span><span class="n">dlon</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">)</span></div>


<div class="viewcode-block" id="atg"><a class="viewcode-back" href="../../PyWFL.geophysics.html#PyWFL.geophysics.atg">[docs]</a><span class="k">def</span> <span class="nf">atg</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get adiabatic temperature gradient or adiabatic lapse rate.</span>

<span class="sd">    Args:</span>
<span class="sd">        s (float) :salinity (unit: psu)</span>
<span class="sd">        t (float) :temperature (unit: deg Celsius)</span>
<span class="sd">        p0 (float) :pressure level (unit: Pascal)</span>

<span class="sd">    Return:</span>
<span class="sd">        float : atg,adiabatic temperature gradient (unit: deg Celsius/decibars).</span>

<span class="sd">    Notes:</span>
<span class="sd">        The adiabatic lapse rate :math:`\\Gamma(s,t,p)` (deg Celsius/decibar) is defined as the change of temperature per unit pressure for an adiabatic change of pressure of an element of seawater. It&#39;s assumed that no heat or salt is exchanged with the surroundings so that the pressure change is both adiabatic and isentropic. From thermodynamic considerations, the adiabatic lapse rate :math:`\\Gamma`, a function of pressure, temperature and salinity can be expressed as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \\Gamma(s,t,p) = T \\left( \\partial V / \\partial t \\right) / C_{p}</span>

<span class="sd">        where :math:`T=t+273.15` is absolute temperature (Kelvin), ( :math:`\\partial V / \\partial t` ) (m3/(kg deg Celsius) ) is thermal expansion and :math:`C_{p}` (J/(kg deg Celsius)) specific heat of seawater at constant pressure.</span>

<span class="sd">        The lapse rate :math:`\\Gamma` is positive except at low salinities, temperatures and pressures where :math:`\\partial V / \\partial t` is negative. Typical values in the oceanic range are 1~2*104 deg Celsius/decibar.</span>

<span class="sd">        Adiabatic lapse rate can be calculated from the equation of state and specific heat (Bryden, 1973) or from direct meansurements.</span>

<span class="sd">    References:</span>
<span class="sd">        .. [1] BRYDEN,H.,1973,DEEP-SEA RES.,20,401-408</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; atg(40, 40, 1e8) # 0.00032559758</span>

<span class="sd">&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_geophysics</span><span class="o">.</span><span class="n">py_wfl_atg</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, YAN Haoming, WU Dingcheng.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>