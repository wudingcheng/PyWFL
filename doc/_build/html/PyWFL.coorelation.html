

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PyWFL.coorelation package &mdash; PyWFL 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="PyWFL 1.0 documentation" href="index.html"/>
        <link rel="up" title="PyWFL package" href="PyWFL.html"/>
        <link rel="next" title="PyWFL.filters package" href="PyWFL.filters.html"/>
        <link rel="prev" title="PyWFL.coordinate package" href="PyWFL.coordinate.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> PyWFL
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">PyWFL</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="PyWFL.html">PyWFL package</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="PyWFL.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="PyWFL.calendar.html">PyWFL.calendar package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.coordinate.html">PyWFL.coordinate package</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">PyWFL.coorelation package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.filters.html">PyWFL.filters package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.fit.html">PyWFL.fit package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.geophysics.html">PyWFL.geophysics package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.harmonics.html">PyWFL.harmonics package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.rand.html">PyWFL.rand package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.spectrum.html">PyWFL.spectrum package</a></li>
<li class="toctree-l4"><a class="reference internal" href="PyWFL.statistics.html">PyWFL.statistics package</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="PyWFL.html#submodules">Submodules</a></li>
<li class="toctree-l3"><a class="reference internal" href="PyWFL.html#module-PyWFL.constant">PyWFL.constant module</a></li>
<li class="toctree-l3"><a class="reference internal" href="PyWFL.html#module-PyWFL">Module contents</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">PyWFL</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="modules.html">PyWFL</a> &raquo;</li>
      
          <li><a href="PyWFL.html">PyWFL package</a> &raquo;</li>
      
    <li>PyWFL.coorelation package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/PyWFL.coorelation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pywfl-coorelation-package">
<h1>PyWFL.coorelation package<a class="headerlink" href="#pywfl-coorelation-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-PyWFL.coorelation">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-PyWFL.coorelation" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="PyWFL.coorelation.arcov">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">arcov</code><span class="sig-paren">(</span><em>x</em>, <em>normalized=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#arcov"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.arcov" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the auto-covariance of a time series</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; x[n], Time series to calculate auto-covariance</li>
<li><strong>normalized</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; if True, then x will be normalized first (so mean(x)=0, std(x)=1), and then calculate the auto-covariance; if False, then only get the auto-covariance without normalized.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">Auto-covariance</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)">array</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The autocorrelation function can be acquired by using r(k)=x_arcov(k)/x_arcov(0), where k=0,...,n-1. Also see ARCO or WFL_MULTICOR.</p>
<p>There two algorithm to calculate autocovariance,  named Algorithm A and Algorithm B, see below for details. Algorithm B is an unbiased estimator of theoretical autocovariance of the ensemble, where Algorithm B is only asymptotically unbiased as the recorder length N tend to infinity. However, it is shown that the biased estimator (Algorithm A) has a smaller mean square error.  It is seen that the two variances of Algorithm A and B coincide when k=0 but as k tends to N the variance of the Algorithm A (biased estimator) tends to zero, whereas the variance of the Algorithm B (unbiased estimator) tends to infinity. It is this behavior which makes the unbiased estimator (Algorithm B) so unsatisfactory.  As a result, here choose Algorithm A to calculate the autocovariance.  See Jenkins and Watts (1968), p174-180, for details.</p>
<dl class="docutils">
<dt>Algorithm A:</dt>
<dd>autocovar(K)=1/N * ( SUM( (X(T)-X_AVERAGE) * ( X(T+K)-X_AVERAGE)  ) Where T=1,N-K ) and K=0,1,...N-1</dd>
<dt>Algorithm B (NOT used):</dt>
<dd>autocovar(K)=1/(N-K)* ( SUM( (X(T)-X_AVERAGE) * ( X(T+K)-X_AVERAGE)  ) Where T=1,N-K ) and K=0,1,...N-1</dd>
<dt>Reference:</dt>
<dd><table class="first last docutils footnote" frame="void" id="id1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications, Holden-Day,  1968.</td></tr>
</tbody>
</table>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="PyWFL.coorelation.cor2">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">cor2</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>dof=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#cor2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.cor2" title="Permalink to this definition">¶</a></dt>
<dd><p>Give correlation coefficient and 95% confidential level between two vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array a</li>
<li><strong>b</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array b</li>
<li><strong>dof</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#int" title="(in Python v2.7)"><em>int</em></a>) &#8211; Degrees of Freedom (DOF), if not equal 0, this value will be used to calculate colev; if 0, DOF will be set to n-2. If you want to do get a more reliable DOF, please use function <a class="reference internal" href="#PyWFL.coorelation.edof" title="PyWFL.coorelation.edof"><code class="xref py py-func docutils literal"><span class="pre">edof()</span></code></a> to get effect DOF and use it here.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li>co (float) : The correlation coefficient between array a and b</li>
<li>colev (float) : The 95% confidential levelarcov of correlation coefficient (Degrees of Freedom is n-2 )</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/2/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>co is between -1 and 1</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">arange</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cor2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="PyWFL.coorelation.corfre">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">corfre</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>dt=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#corfre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.corfre" title="Permalink to this definition">¶</a></dt>
<dd><p>Get  squared coherence amplitude spectrum and phase spectrum in the frequency domain for two vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array a</li>
<li><strong>b</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array b</li>
<li><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; The time interval for time index of array a and b</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">out(i,n-1)&#8211;i=0, frequency; i=1, periods; i=2, squared coherency amplitude spectrum; i=3, phase spectrum; i=4, 95% confidential level for amplitude spectrum</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><ol class="first last upperalpha simple" start="2">
<li><ol class="first upperalpha" start="6">
<li>Chao, correlation of interannual length-of-day variation with El-nino/southern oscillation,1972-1986, J. Geophys. R., Vol.93, pp7709-7715, 1988.</li>
</ol>
</li>
</ol>
</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">arange</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">t</span> <span class="o">-</span> <span class="mf">0.3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corfre</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="PyWFL.coorelation.corlag">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">corlag</code><span class="sig-paren">(</span><em>dt</em>, <em>a</em>, <em>b</em>, <em>dof</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#corlag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.corlag" title="Permalink to this definition">¶</a></dt>
<dd><p>Give time lagged correlation coefficients of two vectors</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; The time interval for time index of array a and b</li>
<li><strong>a</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array a</li>
<li><strong>b</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array b</li>
<li><strong>dof</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Factor of Degrees Of Freedom (DOF) for filtered input vector a and b, if a and b is not filtered, then set  dof=1.0. If array a and b are both filtered by some filter, then the freedom of array a and b will decrease (the value of 95% correlation confidential level will increase), if you know the exact DOF of filtered array a and b, e.g. n1 (n1&lt;n, n is the length of array a, so is array b), then set dof=n1/n will get the exact 95% confidential level; otherwise (set dof=1.0 for filtered a and b) you will get a lower value of 95% confidential level which is not correct.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">out(i,-n/2+2:n/2-2)&#8211;i=1,time index; i=2, correlation coefficients; i=3, positive 95% confidential level; i=4, negative 95% confidential level</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>When you get the maximum correlation coefficient (the most near m=0 point at both positive m and negative m) at out(2, m), if m&gt;0, then array a lead array b; if m&lt;0, then array a lag array b.  See example for details.</p>
<p>To determine the correct DOF for filtered array a or b by using <code class="xref py py-func docutils literal"><span class="pre">vondrak()</span></code> method, please reference:</p>
<p>Yan Haoming, Zhong Min, Zhu Yaozhong, Determination of the degree of freedom of digital filtered time series with an application to the correlation analysis between the length of day and the southern oscillation index, Chinese Astronomy and Astrophysics, Vol. 28, No.1, P120-126, 2004.(in English)</p>
<p>闫昊明，钟敏，朱耀仲，时间序列数字滤波后自由度的确定――应用于日长变化与南方涛动指数的相关分析，天文学报，Vol. 44, No.3, P324-329, 2003. (in Chinese)</p>
<p>If you want use other filter method to filter the original data, and want to get the correct DOF, please also reference the above papers to do your own Monte Carlo analysis to get the correct DOF of filtered data. Or reference function WFL_EDOF for more details for determine effect DOF.</p>
<p>Note: the above definition may different with MATLAB etc. software, be aware that the above equation is more accurate. And due to the factor n/(n-lag), the r(lag) may be great than 1.0 when lag is large, please take more attention about it and only use small lag to determine the lag correlation coefficient.</p>
<p>Sign convention of this routine: if a leads b, i.e., a is shifted to the left of b, then CORLAG  will show a peak at positive lags.</p>
<p>For lag==0, array a(1),a(2)...a(n) and array b(1),b(2)...b(n) do corelation analysis.
For lag==1, array a(1),a(2)...a(n-1) and array b(2),b(3)...b(n) do corelation analysis. b is shifted to left by one step.
For lag==m(m&lt;n/2-2), array a(1),a(2)...a(n-m) and array b(1+m),b(2+m)...b(n) do corelation analysis. b is shifted to left by m steps.
For lag==-1, array a(2),a(3)...a(n) and array b(1),b(2),...b(n-1) do corelation analysis. a is shifted to right by one step.
For lag==-m, array a(1+m),a(2+m),..a(n) and array b(1),b(2),...b(n-m) do corelation analysis. a is shifted to right by m steps.</p>
</dd></dl>

<dl class="function">
<dt id="PyWFL.coorelation.edof">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">edof</code><span class="sig-paren">(</span><em>x</em>, <em>y</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#edof"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.edof" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine the Effect Degree of Freedom (EDOF) of two time series for correlation analysis</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Time series to be analysised</li>
<li><strong>y</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Time series to be analysised</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The effect degree of freedom for time series x and y</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/2/library/functions.html#int" title="(in Python v2.7)">int</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>When do correlation analysis, we often use t test to give a 95% confidence level with DOF as n-2. But this method is only suitable for the time series which is not auto-correlated, for the time series which is auto-correlated, we should use EDOF which is smaller than DOF. So this subroutine is used  to calculate the EDOF of two time series and then use it as the DOF to do correlation analysis in subroutine <a class="reference internal" href="#PyWFL.coorelation.cor2" title="PyWFL.coorelation.cor2"><code class="xref py py-func docutils literal"><span class="pre">cor2()</span></code></a>.</p>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Davis R. E., Predictability of sea-surface temperature and sea-level pressure anomalies over the North pacific ocean, J Phys. Oceanogr., Vol.6, 249-266,1976.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="PyWFL.coorelation.fre_response">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">fre_response</code><span class="sig-paren">(</span><em>dt</em>, <em>x</em>, <em>y</em>, <em>nw</em>, <em>p=0.95</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#fre_response"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.fre_response" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Frequency Response for two time series by using Multitaper smoothing method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; The time interval for time index of array a and b</li>
<li><strong>x</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array x</li>
<li><strong>y</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array y. <span class="math">\(y(f)=h(f)*x(f)\)</span>  in frequency domain, here <span class="math">\(h(f)\)</span> is the frequency response function which will be calculated.</li>
<li><strong>nw</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; DPSS orders 0 to 2*nw-1 required (2&lt;=nw&lt;n/2). Note, here, nw is real or double type. The typical values of nw is 2, 5/2, 3, 7/2, 4. Thus you can get (nw)Pi-multitapers, e.g. for nw=4, you get 4Pi-multitapers. Smaller nw higher frequency precision, greater nw smaller variance in frequency domain.  See <code class="xref py py-func docutils literal"><span class="pre">dpss()</span></code> for more details.</li>
<li><strong>p</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Confidence level for the F-test (0.&lt;p&lt;1.0)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li>fre_res( n/2, 4) : fre_res(:,1), FFT periods (same unit as dt); fre_res(;,2), frequency response function amplitude spectrum; fre_res(:,3), frequency response function phase spectrum; fre_res(:,4), noise spectrum</li>
<li>amp_ci(n/2,2) : 100*P% confidence level confidence intervals for frequency response function amplitude spectrum fre_res(:,2). amp_ci(:,1) is lower confidence intervals, and amp_ci(:,2) is upper confidence intervals.</li>
<li>ph_ci(n/2,2) : 100*P% confidence level confidence intervals for frequency response function phase spectrum fre_res(:,3). ph_ci(:,1) is lower confidence intervals, and ph_ci(:,2) is upper confidence intervals.  Note, if the output ph_ci(i,1)==ph_ci(i,2), it means that there&#8217;s no confidence interval, because the eq. (10.4.4) of Jenkins and Watts(1968) to calculate ph_ci(:,:) is out of the calculation range due to very small squared coherence between x and y. Thus, only at frequency of larger squared coherence value, the phase confidence interval is meaningful.</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/2/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Phase confidence intervals may be failure at some frequencies (usually at larger frequencies which close to Nyquist frequency). In this case, ph_ci(i,1)==ph_ci(i,2)==fre_res(i,3). Be careful of this failure.</p>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications, Holden-Day, 1968. (chapter 10 for details of frequency response function)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Bell, B., Percival, D.B. and Walden, A.T. &#8220;Calculating Thomson&#8217;s Spectral Multitapers by Inverse Iteration&#8221;, J. Comput. and Graph. Stat., 1993.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Percival D. B., and A. T. Walden, Spectral analysis for physical applications: Multitaper and conventional univariate techniques, Cambridge University Press, Cambridge, 583p, 1993.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Thomson, D. J., 1982, Spectral estimation and harmonic analysis: IEEE Proc., v. 70, no. 9, p. 1055-1096.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="PyWFL.coorelation.mtm_coh">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">mtm_coh</code><span class="sig-paren">(</span><em>dt</em>, <em>x</em>, <em>y</em>, <em>nw</em>, <em>p=0.95</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#mtm_coh"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.mtm_coh" title="Permalink to this definition">¶</a></dt>
<dd><p>Get  squared coherence amplitude spectrum and phase spectrum / cross amplitude and phase spectrum in the frequency domain for two vectors by using multitaper(MTM) method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>dt</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; The time interval for time index of array a and b</li>
<li><strong>x</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array x</li>
<li><strong>y</strong> (<a class="reference external" href="https://docs.python.org/2/library/array.html#module-array" title="(in Python v2.7)"><em>array</em></a>) &#8211; Array y. <span class="math">\(y(f)=h(f)*x(f)\)</span>  in frequency domain, here <span class="math">\(h(f)\)</span> is the frequency response function which will be calculated.</li>
<li><strong>nw</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; DPSS orders 0 to 2*nw-1 required (2&lt;=nw&lt;n/2). Note, here, nw is real or double type. The typical values of nw is 2, 5/2, 3, 7/2, 4. Thus you can get (nw)Pi-multitapers, e.g. for nw=4, you get 4Pi-multitapers. Smaller nw higher frequency precision, greater nw smaller variance in frequency domain.  See <code class="xref py py-func docutils literal"><span class="pre">dpss()</span></code> for more details.</li>
<li><strong>p</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#float" title="(in Python v2.7)"><em>float</em></a>) &#8211; Confidence level for the F-test (0.&lt;p&lt;1.0)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><ul class="simple">
<li>coh_spec( n/2, 3):coh_spec(:,1), FFT periods (same unit as dt); coh_spec(;,2), squared coherency amplitude spectrum; coh_spec(:,3), coherency phase spectrum</li>
<li>cross_spec( n/2, 3):cross_spec(:,1), FFT periods (same unit as dt); cross_spec(;,2), cross amplitude spectrum of a and b; cross_spec(:,3), cross phase spectrum</li>
<li>f_test(n/2):100*P% confidence level F-test value for squared coherency amplitude spectrum</li>
</ul>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference external" href="https://docs.python.org/2/library/functions.html#tuple" title="(in Python v2.7)">tuple</a></p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Similar as subroutine <a class="reference internal" href="#PyWFL.coorelation.corfre" title="PyWFL.coorelation.corfre"><code class="xref py py-func docutils literal"><span class="pre">corfre()</span></code></a> bus use multitaper method to calculate the spectrum.</p>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Bell, B., Percival, D.B. and Walden, A.T. &#8220;Calculating Thomson&#8217;s Spectral Multitapers by Inverse Iteration&#8221;, J. Comput. and Graph. Stat., 1993.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Percival D. B., and A. T. Walden, Spectral analysis for physical applications: Multitaper and conventional univariate techniques, Cambridge University Press, Cambridge, 583p, 1993.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Thomson, D. J., 1982, Spectral estimation and harmonic analysis: IEEE Proc., v. 70, no. 9, p. 1055-1096.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[4]</td><td>Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications, Holden-Day, 1968. (chapter 6-9)</td></tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#PyWFL.coorelation.corlag" title="PyWFL.coorelation.corlag"><code class="xref py py-func docutils literal"><span class="pre">corlag()</span></code></a>, <a class="reference internal" href="#PyWFL.coorelation.cor2" title="PyWFL.coorelation.cor2"><code class="xref py py-func docutils literal"><span class="pre">cor2()</span></code></a>, <a class="reference internal" href="#PyWFL.coorelation.corfre" title="PyWFL.coorelation.corfre"><code class="xref py py-func docutils literal"><span class="pre">corfre()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="PyWFL.coorelation.multicor">
<code class="descclassname">PyWFL.coorelation.</code><code class="descname">multicor</code><span class="sig-paren">(</span><em>x</em>, <em>out_type='cor'</em>, <em>fft=False</em>, <em>remove_mean=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/PyWFL/coorelation.html#multicor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#PyWFL.coorelation.multicor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the auto- and cross covariance/correlation of input data (time series)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>x</strong> (<em>ndarray</em>) &#8211; x[n,m], total m time series, each has n points. Time series for calculating auto- and cross covariance/correlation. x was first removed average in the subroutine.</li>
<li><strong>out_type</strong> &#8211; out_type=&#8217;cov&#8217; or &#8216;cor&#8217; for covariance and correlation output</li>
<li><strong>fft</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; if True, use fft method</li>
<li><strong>remove_mean</strong> (<a class="reference external" href="https://docs.python.org/2/library/functions.html#bool" title="(in Python v2.7)"><em>bool</em></a>) &#8211; if True, then first remove mean of input x(n,m) for each column m, if False, no remove mean for the input data x(n,m). If not present  remove_mean, no mean removed from input data x(n,m).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>xout</dt>
<dd><p class="first">Auto- and cross covariance for X if out_type=&#8217;cov&#8217;;
auto- and cross correlation for X, if out_type=&#8217;cor&#8217;
The first index of x(:,:,:) is lags. Thus x_out(0,m,m) is the covariance/correlation of all m series at lag==0. And x_out(:,i,i) is the autocovariance/autocorrelation of the ith series.</p>
<p class="last">when using FFT method, The first index of output x_out(:,m,m)  is different from not using fft.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>Properties of covariance functions:</dt>
<dd><p class="first">The properties of the auto covariance functions of a real bivariate process are the same as those for the auto covariance functions of a univariate  process, that is,</p>
<div class="last math">
\[\begin{split}\gamma_{ii}(0) &amp; = Var\left[ X_i(t) \right ] = \sigma^2_{X_i} \\
\gamma_{ii}(u) &amp; = \gamma_{ii}(-u)\end{split}\]</div>
</dd>
</dl>
<p>Hence the covariance between the two stochastic processed can be described by means of the single cross covariance functions <code class="xref py py-func docutils literal"><span class="pre">gamma_{12}(u)()</span></code>, where <code class="xref py py-func docutils literal"><span class="pre">-infty</span> <span class="pre">leq</span> <span class="pre">u</span> <span class="pre">leq</span> <span class="pre">+infty()</span></code>. Note that although the auto covariance function is an even function of lag, the cross covariance function will <strong>NOT</strong> be an even function in general.</p>
<p>The cross correlation function:</p>
<blockquote>
<div><p>In general it may be necessary to study the interactions between two processes with possibly different scales of measurement or different variances. In this situation it is necessary to define the cross correlation function</p>
<blockquote>
<div><div class="math">
\[\rho_{12}(u) = \gamma_{12}(u) / \sqrt(\gamma_{11}(0)\gamma_{22}(0)) = \gamma_{12}(u)/(\sigma_1 \sigma_2)\]</div>
</div></blockquote>
<p>The first property of the cross correlation function is that</p>
<blockquote>
<div><div class="math">
\[| \rho_{12}(u) | \leq 1\]</div>
</div></blockquote>
<p>which follows from the fact that the random variable</p>
<blockquote>
<div><div class="math">
\[Y(t) = \lambda_1 X_1(t) + \lambda_2 X_2(t+u)\]</div>
</div></blockquote>
<p>has positive variance.
The second property is that</p>
<blockquote>
<div>..math:: rho_{12}(u) = rho_{21}(-u)</div></blockquote>
</div></blockquote>
<p>Sign convention of this routine: if x(:,i) lags x(:,j), i.e., x(:,i) is shifted to the right of x(:,j), then WFL_MULTICOR  will show a peak at positive lags.</p>
<p>Difference between <a class="reference internal" href="#PyWFL.coorelation.multicor" title="PyWFL.coorelation.multicor"><code class="xref py py-func docutils literal"><span class="pre">multicor()</span></code></a> with <a class="reference internal" href="#PyWFL.coorelation.corlag" title="PyWFL.coorelation.corlag"><code class="xref py py-func docutils literal"><span class="pre">corlag()</span></code></a>:</p>
<p>The results of <a class="reference internal" href="#PyWFL.coorelation.multicor" title="PyWFL.coorelation.multicor"><code class="xref py py-func docutils literal"><span class="pre">multicor()</span></code></a> (for auto and cross correlation only) is different with the results of <a class="reference internal" href="#PyWFL.coorelation.corlag" title="PyWFL.coorelation.corlag"><code class="xref py py-func docutils literal"><span class="pre">corlag()</span></code></a> in three parts: first, <a class="reference internal" href="#PyWFL.coorelation.corlag" title="PyWFL.coorelation.corlag"><code class="xref py py-func docutils literal"><span class="pre">corlag()</span></code></a> has a factor of n/(n-lag) while <a class="reference internal" href="#PyWFL.coorelation.multicor" title="PyWFL.coorelation.multicor"><code class="xref py py-func docutils literal"><span class="pre">multicor()</span></code></a> has the factor 1.0;  second, <a class="reference internal" href="#PyWFL.coorelation.corlag" title="PyWFL.coorelation.corlag"><code class="xref py py-func docutils literal"><span class="pre">corlag()</span></code></a> use different variance (each n-lag data) while <a class="reference internal" href="#PyWFL.coorelation.multicor" title="PyWFL.coorelation.multicor"><code class="xref py py-func docutils literal"><span class="pre">multicor()</span></code></a> use the same variance cov(0,i,i); and third, the sign convention of func:<cite>corlag</cite> is reverse with that of <a class="reference internal" href="#PyWFL.coorelation.multicor" title="PyWFL.coorelation.multicor"><code class="xref py py-func docutils literal"><span class="pre">multicor()</span></code></a>.</p>
<p class="rubric">Examples</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">47</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">65</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">59</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">71</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">56</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">58</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span>
<span class="go">               37, 74, 51, 58, 50, 60, 44, 57, 50, 45, 25, 59, 50, 71, 56, 74, 50, 58,</span>
<span class="go">               45, 54, 36, 54, 48, 55, 45, 57, 50, 62, 44, 64, 43, 52, 38, 60, 55, 41,</span>
<span class="go">               53, 49, 34, 35, 54, 45, 68, 38, 50, 60],</span>
<span class="go">              [47, 64, 23, 71, 38, 65, 55, 41, 59, 48, 71, 35, 56, 40, 58, 44, 80, 55,</span>
<span class="go">               37, 74, 51, 58, 50, 60, 44, 57, 50, 45, 25, 59, 50, 71, 56, 74, 50, 58,</span>
<span class="go">               45, 54, 36, 54, 48, 55, 45, 57, 50, 62, 44, 64, 43, 52, 38, 60, 55, 41,</span>
<span class="go">               53, 49, 34, 35, 54, 45, 68, 38, 50, 60]]).T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multicor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fft</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">multicor</span><span class="p">(</span><span class="n">x</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p class="rubric">References</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>Jenkins, G. M., and D. G., Watts, Spectral analysis and its applications,  P207-208, P322-325, Holden-Day, 1968.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="PyWFL.filters.html" class="btn btn-neutral float-right" title="PyWFL.filters package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="PyWFL.coordinate.html" class="btn btn-neutral" title="PyWFL.coordinate package" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, YAN Haoming, WU Dingcheng.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>